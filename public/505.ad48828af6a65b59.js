"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[505],{3505:(k,p,s)=>{s.r(p),s.d(p,{InputTransformComponent:()=>l});var i=s(6895),c=s(827),m=s(8512),e=s(8256),d=s(529);const g=["notesRef"],Z=["bestRef"],f=["prosConsRef"],_=["topicsRef"];function T(n,r){1&n&&e.GkF(0)}function A(n,r){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,T,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(28);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function U(n,r){1&n&&e.GkF(0)}function h(n,r){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,U,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(30);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function q(n,r){1&n&&e.GkF(0)}function v(n,r){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,q,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(32);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function y(n,r){1&n&&e.GkF(0)}function b(n,r){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,y,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(26);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}const u=function(){return["typescript"]};function C(n,r){if(1&n){const t=e.EpF();e.TgZ(0,"p"),e._uU(1,"What is Input Transform?"),e.qZA(),e.TgZ(2,"ul",16)(3,"li")(4,"strong"),e._uU(5,"Input Property Transformation"),e.qZA(),e._uU(6,": A feature that lets you transform input values as they enter a component. "),e.qZA(),e.TgZ(7,"li")(8,"strong"),e._uU(9,"Reactive Integration"),e.qZA(),e._uU(10,": Works seamlessly with Angular's signal-based reactivity system. "),e.qZA(),e.TgZ(11,"li")(12,"strong"),e._uU(13,"Cleaner Component Logic"),e.qZA(),e._uU(14,": Moves data manipulation logic directly into the input declaration. "),e.qZA(),e.TgZ(15,"li")(16,"strong"),e._uU(17,"Type-Safe Transformations"),e.qZA(),e._uU(18,": Maintains TypeScript type safety throughout the transformation pipeline. "),e.qZA()(),e._UZ(19,"br")(20,"br"),e.TgZ(21,"p"),e._uU(22,"Basic Input Transform Example"),e.qZA(),e.TgZ(23,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(26);return e.KtG(o.hidden=!o.hidden)}),e._uU(24,"code"),e.qZA(),e.TgZ(25,"span",18,19)(27,"div",20)(28,"span"),e._uU(29,"typescript"),e.qZA(),e._UZ(30,"span",21),e.qZA(),e.TgZ(31,"pre"),e._uU(32,"      "),e.TgZ(33,"code",22),e._uU(34,"\n      "),e.qZA(),e._uU(35,"\n    "),e.qZA()(),e._UZ(36,"br")(37,"br"),e.TgZ(38,"p"),e._uU(39,"Multiple Input Transforms"),e.qZA(),e.TgZ(40,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(43);return e.KtG(o.hidden=!o.hidden)}),e._uU(41,"code"),e.qZA(),e.TgZ(42,"span",18,23)(44,"div",20)(45,"span"),e._uU(46,"typescript"),e.qZA(),e._UZ(47,"span",21),e.qZA(),e.TgZ(48,"pre"),e._uU(49,"      "),e.TgZ(50,"code",22),e._uU(51,"\n      "),e.qZA(),e._uU(52,"\n    "),e.qZA()(),e._UZ(53,"br")(54,"br"),e.TgZ(55,"p"),e._uU(56,"Complex Transforms with Input Functions"),e.qZA(),e.TgZ(57,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(60);return e.KtG(o.hidden=!o.hidden)}),e._uU(58,"code"),e.qZA(),e.TgZ(59,"span",18,24)(61,"div",20)(62,"span"),e._uU(63,"typescript"),e.qZA(),e._UZ(64,"span",21),e.qZA(),e.TgZ(65,"pre"),e._uU(66,"      "),e.TgZ(67,"code",22),e._uU(68,"\n      "),e.qZA(),e._uU(69,"\n    "),e.qZA()(),e._UZ(70,"br")(71,"br"),e.TgZ(72,"p"),e._uU(73,"Angular 19 Input Transform Enhancements"),e.qZA(),e.TgZ(74,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(77);return e.KtG(o.hidden=!o.hidden)}),e._uU(75,"code"),e.qZA(),e.TgZ(76,"span",18,25)(78,"div",20)(79,"span"),e._uU(80,"typescript"),e.qZA(),e._UZ(81,"span",21),e.qZA(),e.TgZ(82,"pre"),e._uU(83,"      "),e.TgZ(84,"code",22),e._uU(85,"\n      "),e.qZA(),e._uU(86,"\n    "),e.qZA()(),e._UZ(87,"br")(88,"br"),e.TgZ(89,"p"),e._uU(90,"Architecture Patterns with Input Transform"),e.qZA(),e.TgZ(91,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(94);return e.KtG(o.hidden=!o.hidden)}),e._uU(92,"code"),e.qZA(),e.TgZ(93,"span",18,26)(95,"div",20)(96,"span"),e._uU(97,"typescript"),e.qZA(),e._UZ(98,"span",21),e.qZA(),e.TgZ(99,"pre"),e._uU(100,"      "),e.TgZ(101,"code",22),e._uU(102,"\n      "),e.qZA(),e._uU(103,"\n    "),e.qZA()(),e._UZ(104,"br")(105,"br"),e.TgZ(106,"p"),e._uU(107,"Input Transform Key Features"),e.qZA(),e.TgZ(108,"table",27)(109,"thead")(110,"tr",28)(111,"th",29),e._uU(112,"Feature"),e.qZA(),e.TgZ(113,"th",29),e._uU(114,"Description"),e.qZA(),e.TgZ(115,"th",29),e._uU(116,"Benefits"),e.qZA()()(),e.TgZ(117,"tbody")(118,"tr",30)(119,"td",31),e._uU(120,"Value Transformation"),e.qZA(),e.TgZ(121,"td",31),e._uU(122,"Transform raw input values into formatted, validated data"),e.qZA(),e.TgZ(123,"td",31),e._uU(124,"Clean data always available in component without extra logic"),e.qZA()(),e.TgZ(125,"tr",32)(126,"td",31),e._uU(127,"Dependency Tracking"),e.qZA(),e.TgZ(128,"td",31),e._uU(129,"Transforms can depend on other inputs or signals"),e.qZA(),e.TgZ(130,"td",31),e._uU(131,"Automatically updates when dependencies change"),e.qZA()(),e.TgZ(132,"tr",30)(133,"td",31),e._uU(134,"Type Safety"),e.qZA(),e.TgZ(135,"td",31),e._uU(136,"Full TypeScript support for input and output types"),e.qZA(),e.TgZ(137,"td",31),e._uU(138,"Prevents errors and improves development experience"),e.qZA()(),e.TgZ(139,"tr",33)(140,"td",31),e._uU(141,"Async Support"),e.qZA(),e.TgZ(142,"td",31),e._uU(143,"Transform functions can be asynchronous"),e.qZA(),e.TgZ(144,"td",31),e._uU(145,"Enables API calls or complex async operations in transforms"),e.qZA()()()()}if(2&n){const t=e.oxw();e.xp6(33),e.Q6J("highlight",t.basicExampleCode)("languages",e.DdM(10,u)),e.xp6(17),e.Q6J("highlight",t.multiInputExampleCode)("languages",e.DdM(11,u)),e.xp6(17),e.Q6J("highlight",t.complexTransformExampleCode)("languages",e.DdM(12,u)),e.xp6(17),e.Q6J("highlight",t.v19EnhancementsCode)("languages",e.DdM(13,u)),e.xp6(17),e.Q6J("highlight",t.architectureExampleCode)("languages",e.DdM(14,u))}}function x(n,r){1&n&&(e.TgZ(0,"ol",34)(1,"li")(2,"strong",35),e._uU(3,"Keep Transforms Pure and Focused"),e.qZA(),e.TgZ(4,"ul",36)(5,"li")(6,"strong"),e._uU(7,"Single Responsibility"),e.qZA(),e._uU(8,": Each transform should have a clear, single purpose (formatting, validation, etc.). "),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"Avoid Side Effects"),e.qZA(),e._uU(12,": Transforms should not change component state or trigger external actions. "),e.qZA(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Prefer Immutability"),e.qZA(),e._uU(16,": Return new objects rather than mutating input values. "),e.qZA()()(),e.TgZ(17,"li")(18,"strong",35),e._uU(19,"Plan Your Transform Dependencies"),e.qZA(),e.TgZ(20,"ul",36)(21,"li")(22,"strong"),e._uU(23,"Dependency Order"),e.qZA(),e._uU(24,": Define inputs in the proper order if transforms depend on other inputs. "),e.qZA(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Avoid Circular Dependencies"),e.qZA(),e._uU(28,": Don't create transforms that depend on each other in a circular manner. "),e.qZA(),e.TgZ(29,"li")(30,"strong"),e._uU(31,"Use Computed for Derived Values"),e.qZA(),e._uU(32,": If you only need to derive values without transforming inputs, use computed() instead. "),e.qZA()()(),e.TgZ(33,"li")(34,"strong",35),e._uU(35,"Handle Edge Cases Gracefully"),e.qZA(),e.TgZ(36,"ul",36)(37,"li")(38,"strong"),e._uU(39,"Default Values"),e.qZA(),e._uU(40,": Always provide sensible defaults for when inputs are undefined. "),e.qZA(),e.TgZ(41,"li")(42,"strong"),e._uU(43,"Validation"),e.qZA(),e._uU(44,": Include appropriate validation in transforms to prevent unexpected values. "),e.qZA(),e.TgZ(45,"li")(46,"strong"),e._uU(47,"Error Handling"),e.qZA(),e._uU(48,": Properly handle errors in transforms, especially for async transforms. "),e.qZA()()(),e.TgZ(49,"li")(50,"strong",35),e._uU(51,"Optimize for Performance"),e.qZA(),e.TgZ(52,"ul",36)(53,"li")(54,"strong"),e._uU(55,"Keep Transforms Efficient"),e.qZA(),e._uU(56,": Avoid computationally intensive operations in transforms that run frequently. "),e.qZA(),e.TgZ(57,"li")(58,"strong"),e._uU(59,"Debounce Frequent Changes"),e.qZA(),e._uU(60,": For inputs that change rapidly, consider implementing debouncing. "),e.qZA(),e.TgZ(61,"li")(62,"strong"),e._uU(63,"Cache Complex Results"),e.qZA(),e._uU(64,": Use memoization techniques for expensive transformations. "),e.qZA()()(),e.TgZ(65,"li")(66,"strong",35),e._uU(67,"Document Your Transforms"),e.qZA(),e.TgZ(68,"ul",36)(69,"li")(70,"strong"),e._uU(71,"Clear Comments"),e.qZA(),e._uU(72,": Document what each transform does, especially for complex transforms. "),e.qZA(),e.TgZ(73,"li")(74,"strong"),e._uU(75,"Type Annotations"),e.qZA(),e._uU(76,": Use explicit TypeScript types for both input and output of transforms. "),e.qZA(),e.TgZ(77,"li")(78,"strong"),e._uU(79,"Document Assumptions"),e.qZA(),e._uU(80,": Make clear any assumptions about input values or dependencies. "),e.qZA()()()())}function w(n,r){1&n&&(e.TgZ(0,"strong",35),e._uU(1," Pros: "),e.qZA(),e._UZ(2,"br"),e.TgZ(3,"ol",37)(4,"li")(5,"strong"),e._uU(6,"Cleaner Component Logic"),e.qZA(),e.TgZ(7,"ul",36)(8,"li")(9,"span",3),e._uU(10,"Declarative Approach"),e.qZA(),e._uU(11,": Transforms move data manipulation logic directly into input declarations. "),e.qZA(),e.TgZ(12,"li")(13,"span",3),e._uU(14,"Reduced Boilerplate"),e.qZA(),e._uU(15,": Eliminates the need for separate getters/setters or ngOnChanges. "),e.qZA(),e.TgZ(16,"li")(17,"span",3),e._uU(18,"Self-Contained Logic"),e.qZA(),e._uU(19,": Keep input handling logic close to where the input is defined. "),e.qZA()()(),e.TgZ(20,"li")(21,"strong"),e._uU(22,"Enhanced Type Safety"),e.qZA(),e.TgZ(23,"ul",36)(24,"li")(25,"span",3),e._uU(26,"Strong Typing"),e.qZA(),e._uU(27,": Full TypeScript support for both incoming values and transformed results. "),e.qZA(),e.TgZ(28,"li")(29,"span",3),e._uU(30,"Compile-Time Checks"),e.qZA(),e._uU(31,": Type errors are caught at compile time rather than runtime. "),e.qZA(),e.TgZ(32,"li")(33,"span",3),e._uU(34,"Better IntelliSense"),e.qZA(),e._uU(35,": Improved IDE support for working with transformed values. "),e.qZA()()(),e.TgZ(36,"li")(37,"strong"),e._uU(38,"Reactive Integration"),e.qZA(),e.TgZ(39,"ul",36)(40,"li")(41,"span",3),e._uU(42,"Seamless Signal Integration"),e.qZA(),e._uU(43,": Works perfectly with Angular's signal-based reactivity system. "),e.qZA(),e.TgZ(44,"li")(45,"span",3),e._uU(46,"Automatic Updates"),e.qZA(),e._uU(47,": Transforms re-run automatically when dependencies change. "),e.qZA(),e.TgZ(48,"li")(49,"span",3),e._uU(50,"Fine-Grained Reactivity"),e.qZA(),e._uU(51,": Updates only components affected by input changes. "),e.qZA()()(),e.TgZ(52,"li")(53,"strong"),e._uU(54,"Better Reusability"),e.qZA(),e.TgZ(55,"ul",36)(56,"li")(57,"span",3),e._uU(58,"Encapsulated Validation"),e.qZA(),e._uU(59,": Components can handle their own input validation. "),e.qZA(),e.TgZ(60,"li")(61,"span",3),e._uU(62,"Standardized Interfaces"),e.qZA(),e._uU(63,": Transforms can normalize different input formats to a standard internal format. "),e.qZA(),e.TgZ(64,"li")(65,"span",3),e._uU(66,"Clean Component APIs"),e.qZA(),e._uU(67,": Makes components more self-contained and easier to reuse. "),e.qZA()()()(),e._UZ(68,"br")(69,"br"),e.TgZ(70,"strong",35),e._uU(71," Cons: "),e.qZA(),e._UZ(72,"br"),e.TgZ(73,"ol",37)(74,"li")(75,"strong"),e._uU(76,"Potential Complexity"),e.qZA(),e.TgZ(77,"ul",36)(78,"li")(79,"span",3),e._uU(80,"Dependency Tracking"),e.qZA(),e._uU(81,": Complex dependency chains between transforms can be difficult to understand. "),e.qZA(),e.TgZ(82,"li")(83,"span",3),e._uU(84,"Hidden Logic"),e.qZA(),e._uU(85,": Transform logic can be less visible than explicit methods. "),e.qZA(),e.TgZ(86,"li")(87,"span",3),e._uU(88,"Debugging Challenges"),e.qZA(),e._uU(89,": Issues within transforms can sometimes be harder to debug. "),e.qZA()()(),e.TgZ(90,"li")(91,"strong"),e._uU(92,"Performance Considerations"),e.qZA(),e.TgZ(93,"ul",36)(94,"li")(95,"span",3),e._uU(96,"Execution Frequency"),e.qZA(),e._uU(97,": Transforms might run more often than needed if dependencies change frequently. "),e.qZA(),e.TgZ(98,"li")(99,"span",3),e._uU(100,"Resource Usage"),e.qZA(),e._uU(101,": Complex transforms on large data structures can impact performance. "),e.qZA(),e.TgZ(102,"li")(103,"span",3),e._uU(104,"Memory Overhead"),e.qZA(),e._uU(105,": Creating new objects in transforms can increase memory usage. "),e.qZA()()(),e.TgZ(106,"li")(107,"strong"),e._uU(108,"Learning Curve"),e.qZA(),e.TgZ(109,"ul",36)(110,"li")(111,"span",3),e._uU(112,"New Pattern"),e.qZA(),e._uU(113,": Developers need to learn this new approach to input handling. "),e.qZA(),e.TgZ(114,"li")(115,"span",3),e._uU(116,"Conceptual Shift"),e.qZA(),e._uU(117,": Requires understanding reactive programming concepts. "),e.qZA(),e.TgZ(118,"li")(119,"span",3),e._uU(120,"Pattern Evolution"),e.qZA(),e._uU(121,": Best practices for input transforms are still evolving. "),e.qZA()()(),e.TgZ(122,"li")(123,"strong"),e._uU(124,"Limited Backward Compatibility"),e.qZA(),e.TgZ(125,"ul",36)(126,"li")(127,"span",3),e._uU(128,"Angular Version Requirement"),e.qZA(),e._uU(129,": Only available in Angular 19+, not usable in older projects. "),e.qZA(),e.TgZ(130,"li")(131,"span",3),e._uU(132,"Migration Effort"),e.qZA(),e._uU(133,": Converting existing input patterns to use transforms requires refactoring. "),e.qZA(),e.TgZ(134,"li")(135,"span",3),e._uU(136,"Signal Dependency"),e.qZA(),e._uU(137,": Fully leveraging transforms requires adopting the signals architecture. "),e.qZA()()()())}function I(n,r){1&n&&(e.TgZ(0,"ol",37)(1,"li")(2,"strong"),e._uU(3,"Angular Signals"),e.qZA(),e.TgZ(4,"ul",36)(5,"li")(6,"strong",35),e._uU(7,"Description"),e.qZA(),e._uU(8,": Angular's reactive primitives for state management. "),e.qZA(),e.TgZ(9,"li")(10,"strong",35),e._uU(11,"Relation to Input Transform"),e.qZA(),e._uU(12,": Input transforms are built on the signals architecture and can depend on signal values. "),e.qZA()()(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Computed Values"),e.qZA(),e.TgZ(16,"ul",36)(17,"li")(18,"strong",35),e._uU(19,"Description"),e.qZA(),e._uU(20,": Derived values that automatically update when their dependencies change. "),e.qZA(),e.TgZ(21,"li")(22,"strong",35),e._uU(23,"Relation to Input Transform"),e.qZA(),e._uU(24,": Input transforms can use computed values, and computed values can use transformed inputs. "),e.qZA()()(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Two-Way Binding with model()"),e.qZA(),e.TgZ(28,"ul",36)(29,"li")(30,"strong",35),e._uU(31,"Description"),e.qZA(),e._uU(32,": Angular 19's approach to two-way data binding using signals. "),e.qZA(),e.TgZ(33,"li")(34,"strong",35),e._uU(35,"Relation to Input Transform"),e.qZA(),e._uU(36,": Can be combined with input transforms for more powerful two-way binding patterns. "),e.qZA()()(),e.TgZ(37,"li")(38,"strong"),e._uU(39,"Form Control Validation"),e.qZA(),e.TgZ(40,"ul",36)(41,"li")(42,"strong",35),e._uU(43,"Description"),e.qZA(),e._uU(44,": Validating and processing user input in forms. "),e.qZA(),e.TgZ(45,"li")(46,"strong",35),e._uU(47,"Relation to Input Transform"),e.qZA(),e._uU(48,": Input transforms can provide an alternative approach to form value processing and validation. "),e.qZA()()(),e.TgZ(49,"li")(50,"strong"),e._uU(51,"Change Detection"),e.qZA(),e.TgZ(52,"ul",36)(53,"li")(54,"strong",35),e._uU(55,"Description"),e.qZA(),e._uU(56,": How Angular detects and responds to state changes. "),e.qZA(),e.TgZ(57,"li")(58,"strong",35),e._uU(59,"Relation to Input Transform"),e.qZA(),e._uU(60,": Input transforms participate in signal-based change detection, improving performance. "),e.qZA()()(),e.TgZ(61,"li")(62,"strong"),e._uU(63,"Component Architecture"),e.qZA(),e.TgZ(64,"ul",36)(65,"li")(66,"strong",35),e._uU(67,"Description"),e.qZA(),e._uU(68,": Patterns for structuring Angular components and their interactions. "),e.qZA(),e.TgZ(69,"li")(70,"strong",35),e._uU(71,"Relation to Input Transform"),e.qZA(),e._uU(72,": Transforms can simplify component APIs and improve component boundaries. "),e.qZA()()(),e.TgZ(73,"li")(74,"strong"),e._uU(75,"Zoneless Applications"),e.qZA(),e.TgZ(76,"ul",36)(77,"li")(78,"strong",35),e._uU(79,"Description"),e.qZA(),e._uU(80,": Angular applications that don't rely on Zone.js for change detection. "),e.qZA(),e.TgZ(81,"li")(82,"strong",35),e._uU(83,"Relation to Input Transform"),e.qZA(),e._uU(84,": Input transforms work well in zoneless applications as part of the signals architecture. "),e.qZA()()()())}class l extends m.Y{constructor(r){super(),this.http=r,this.selectedTab=1,this.basicExampleCode="// Basic Input Transform Example\nimport { Component, input } from '@angular/core';\n\n@Component({\n  selector: 'app-price-display',\n  standalone: true,\n  template: `\n    <div class=\"price\">{{ price() }}</div>\n  `\n})\nexport class PriceDisplayComponent {\n  // Transform a number into a formatted currency string\n  price = input<number>(0, {\n    transform: (value: number) => `$${value.toFixed(2)}`\n  });\n}\n\n// Usage in parent component\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-price-display [price]=\"productPrice\" />\n  `\n})\nexport class ParentComponent {\n  productPrice = 25.99;\n}",this.multiInputExampleCode="// Multiple Input Transforms\nimport { Component, input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  standalone: true,\n  template: `\n    <div class=\"card\">\n      <div class=\"name\">{{ fullName() }}</div>\n      <div class=\"username\">{{ username() }}</div>\n      <div class=\"joined\">Member since: {{ joinDate() }}</div>\n    </div>\n  `\n})\nexport class UserCardComponent {\n  // Transform first and last name into a full name\n  firstName = input<string>('', {\n    alias: 'first'\n  });\n\n  lastName = input<string>('', {\n    alias: 'last'\n  });\n\n  // Derive fullName from firstName and lastName\n  fullName = input<string>('', {\n    transform: () => {\n      return `${this.firstName()} ${this.lastName()}`.trim();\n    }\n  });\n\n  // Validate and transform username\n  username = input<string>('', {\n    transform: (value: string) => {\n      // Convert to lowercase and remove spaces\n      return value.toLowerCase().replace(/\\s/g, '');\n    }\n  });\n\n  // Format date string\n  joinTimestamp = input<number>(0);\n\n  joinDate = input<string>('', {\n    transform: () => {\n      const date = new Date(this.joinTimestamp());\n      return date.toLocaleDateString();\n    }\n  });\n}",this.complexTransformExampleCode="// Complex Transforms with Input Functions\nimport { Component, input, computed } from '@angular/core';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n}\n\n@Component({\n  selector: 'app-product-card',\n  standalone: true,\n  template: `\n    <div class=\"product\" [class.out-of-stock]=\"!isAvailable()\">\n      <h3>{{ product().name }}</h3>\n      <div class=\"price\">{{ formattedPrice() }}</div>\n      <div class=\"status\">{{ statusMessage() }}</div>\n    </div>\n  `\n})\nexport class ProductCardComponent {\n  // Transform raw product data with validation\n  product = input<Product>({\n    id: 0,\n    name: 'Unknown',\n    price: 0,\n    inStock: false\n  }, {\n    transform: (value: any) => {\n      // Validate and provide defaults for missing properties\n      return {\n        id: value?.id ?? 0,\n        name: value?.name ?? 'Unknown Product',\n        price: parseFloat(value?.price) || 0,\n        inStock: Boolean(value?.inStock)\n      };\n    }\n  });\n\n  // Derived state from the transformed input\n  isAvailable = computed(() => this.product().inStock);\n\n  formattedPrice = computed(() => {\n    const price = this.product().price;\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD'\n    }).format(price);\n  });\n\n  statusMessage = computed(() => {\n    return this.isAvailable() ? 'In Stock' : 'Out of Stock';\n  });\n}",this.v19EnhancementsCode="// Angular 19 Input Transform Enhancements\nimport { Component, input, model, computed } from '@angular/core';\n\n// 1. Reactive transform with computed values\n@Component({\n  selector: 'app-reactive-transform',\n  template: `<div>{{ displayValue() }}</div>`\n})\nexport class ReactiveTransformComponent {\n  // Base input\n  count = input<number>(0);\n\n  // Transform that automatically updates when dependencies change\n  displayValue = input<string>('', {\n    transform: () => {\n      const currentCount = this.count();\n      if (currentCount <= 0) return 'No items';\n      if (currentCount === 1) return '1 item';\n      return `${currentCount} items`;\n    }\n  });\n}\n\n// 2. Two-way binding with model() and transform\n@Component({\n  selector: 'app-currency-input',\n  template: `\n    <input\n      type=\"text\"\n      [value]=\"displayValue()\"\n      (input)=\"updateValue($event)\"\n    />\n  `\n})\nexport class CurrencyInputComponent {\n  // Two-way bindable model with transform\n  amount = model<number>(0);\n\n  // Format for display\n  displayValue = computed(() => {\n    return `$${this.amount().toFixed(2)}`;\n  });\n\n  // Parse user input back to number\n  updateValue(event: Event) {\n    const input = (event.target as HTMLInputElement).value;\n    // Remove currency symbol and convert to number\n    const numericValue = parseFloat(input.replace(/[^0-9.-]+/g, ''));\n\n    if (!isNaN(numericValue)) {\n      this.amount.set(numericValue);\n    }\n  }\n}\n\n// 3. Async transform with error handling\n@Component({\n  selector: 'app-async-transform',\n  template: `\n    <div *ngIf=\"userData().status === 'loading'\">Loading...</div>\n    <div *ngIf=\"userData().status === 'error'\">Error: {{ userData().error }}</div>\n    <div *ngIf=\"userData().status === 'success'\">\n      Welcome, {{ userData().data?.name }}!\n    </div>\n  `\n})\nexport class AsyncTransformComponent {\n  userId = input<string>('');\n\n  userData = input<{\n    status: 'loading' | 'success' | 'error';\n    data?: any;\n    error?: string;\n  }>({ status: 'loading' }, {\n    transform: async (id: string) => {\n      if (!id) return { status: 'error', error: 'No user ID provided' };\n\n      try {\n        // Mark as loading during fetch\n        this.userData.set({ status: 'loading' });\n\n        const response = await fetch(`https://api.example.com/users/${id}`);\n        if (!response.ok) throw new Error('Failed to fetch user data');\n\n        const data = await response.json();\n        return { status: 'success', data };\n      } catch (error) {\n        return {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Unknown error'\n        };\n      }\n    }\n  });\n}",this.architectureExampleCode="// Architecture Patterns with Input Transform\nimport { Component, input, computed, inject } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { filter, debounceTime, switchMap } from 'rxjs/operators';\nimport { UserService } from './user.service';\n\n// 1. Service Integration\n@Component({\n  selector: 'app-user-search',\n  template: `\n    <div class=\"search-results\">\n      <div *ngFor=\"let user of processedUsers()\">\n        {{ user.displayName }}\n      </div>\n    </div>\n  `\n})\nexport class UserSearchComponent {\n  private userService = inject(UserService);\n\n  // Transform raw query into normalized search term\n  searchQuery = input<string>('', {\n    transform: (value: string) => value.trim().toLowerCase()\n  });\n\n  // Process user data with transforms\n  processedUsers = input<any[]>([], {\n    transform: async (query: string) => {\n      if (query.length < 2) return [];\n\n      const users = await this.userService.searchUsers(query).toPromise();\n      return users.map(user => ({\n        ...user,\n        displayName: `${user.firstName} ${user.lastName}`,\n        initials: `${user.firstName[0]}${user.lastName[0]}`.toUpperCase()\n      }));\n    }\n  });\n}\n\n// 2. Form Integration\n@Component({\n  selector: 'app-address-form',\n  template: `\x3c!-- Form template --\x3e`\n})\nexport class AddressFormComponent {\n  // Transform and validate postal code\n  postalCode = input<string>('', {\n    transform: (value: string) => {\n      // Format as XXXXX or XXXXX-XXXX\n      const cleaned = value.replace(/[^0-9]/g, '');\n      if (cleaned.length <= 5) return cleaned;\n      return `${cleaned.slice(0, 5)}-${cleaned.slice(5, 9)}`;\n    }\n  });\n\n  // Validate postal code\n  isValidPostalCode = computed(() => {\n    const code = this.postalCode();\n    return /^\\d{5}(-\\d{4})?$/.test(code);\n  });\n}"}ngOnInit(){}}l.\u0275fac=function(r){return new(r||l)(e.Y36(d.eN))},l.\u0275cmp=e.Xpm({type:l,selectors:[["app-input-transform"]],viewQuery:function(r,t){if(1&r&&(e.Gf(g,5),e.Gf(Z,5),e.Gf(f,5),e.Gf(_,5)),2&r){let a;e.iGM(a=e.CRH())&&(t.notesRef=a.first),e.iGM(a=e.CRH())&&(t.bestRef=a.first),e.iGM(a=e.CRH())&&(t.prosConsRef=a.first),e.iGM(a=e.CRH())&&(t.topicsRef=a.first)}},standalone:!0,features:[e.qOj,e.jDz],decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],["code4",""],["code5",""],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"list-disc","pl-4"],[1,"list-decimal","px-10","text-sm"]],template:function(r,t){1&r&&(e.TgZ(0,"section",0)(1,"p",1),e._uU(2," Input Transform "),e.qZA(),e.TgZ(3,"div",2)(4,"p")(5,"span",3),e._uU(6,"Input Transform"),e.qZA(),e._uU(7," is a powerful feature in Angular 19 that allows you to transform input values as they enter a component, providing clean data manipulation, validation, and formatting without cluttering component logic. "),e.qZA(),e._UZ(8,"br"),e.TgZ(9,"div",4)(10,"div",5)(11,"button",6),e.NdJ("click",function(){return t.selectedTab=1}),e._uU(12," Notes "),e.qZA(),e.TgZ(13,"button",6),e.NdJ("click",function(){return t.selectedTab=2}),e._uU(14," Best Practices "),e.qZA(),e.TgZ(15,"button",6),e.NdJ("click",function(){return t.selectedTab=3}),e._uU(16," Pros and Cons "),e.qZA(),e.TgZ(17,"button",6),e.NdJ("click",function(){return t.selectedTab=4}),e._uU(18," Related Topics "),e.qZA()(),e.TgZ(19,"div",7),e.ynx(20,8),e.YNc(21,A,2,1,"div",9),e.YNc(22,h,2,1,"div",9),e.YNc(23,v,2,1,"div",9),e.YNc(24,b,2,1,"div",10),e.BQk(),e.qZA()()()(),e.YNc(25,C,146,15,"ng-template",null,11,e.W1O),e.YNc(27,x,81,0,"ng-template",null,12,e.W1O),e.YNc(29,w,138,0,"ng-template",null,13,e.W1O),e.YNc(31,I,85,0,"ng-template",null,14,e.W1O)),2&r&&(e.xp6(11),e.ekj("text-rose-300",1===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",2===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",3===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",4===t.selectedTab),e.xp6(3),e.Q6J("ngSwitch",t.selectedTab),e.xp6(1),e.Q6J("ngSwitchCase",2),e.xp6(1),e.Q6J("ngSwitchCase",3),e.xp6(1),e.Q6J("ngSwitchCase",4))},dependencies:[i.ez,i.tP,i.RF,i.n9,i.ED,c._l,c.y$],styles:["p[_ngcontent-%COMP%]{margin:0}"]})}}]);