"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[780],{4780:(F,c,a)=>{a.r(c),a.d(c,{OutputModule:()=>r});var s=a(6895),g=a(7178),t=a(8256),d=a(827);const m=["code1"],Z=["code2"],_=["code3"],A=["code4"],f=["notesRef"],h=["bestRef"],T=["prosConsRef"],U=["topicsRef"];function b(n,i){1&n&&t.GkF(0)}function q(n,i){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,b,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(28);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function v(n,i){1&n&&t.GkF(0)}function C(n,i){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,v,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(30);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function y(n,i){1&n&&t.GkF(0)}function w(n,i){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,y,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(32);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function x(n,i){1&n&&t.GkF(0)}function O(n,i){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,x,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(26);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}const l=function(){return["typescript"]},k=function(){return["html"]};function E(n,i){if(1&n){const e=t.EpF();t.TgZ(0,"p"),t._uU(1,"What is @Output?"),t.qZA(),t.TgZ(2,"ul",16)(3,"li")(4,"strong"),t._uU(5,"Event Emitter"),t.qZA(),t._uU(6,": An Output property emits events to notify the parent component of changes. "),t.qZA(),t.TgZ(7,"li")(8,"strong"),t._uU(9,"Component Communication"),t.qZA(),t._uU(10,": Enables child-to-parent component communication in Angular applications. "),t.qZA(),t.TgZ(11,"li")(12,"strong"),t._uU(13,"Data Flow"),t.qZA(),t._uU(14,": Part of Angular's mechanism for maintaining unidirectional data flow. "),t.qZA(),t.TgZ(15,"li")(16,"strong"),t._uU(17,"Event Binding"),t.qZA(),t._uU(18,": Used with event binding syntax in parent component templates. "),t.qZA()(),t._UZ(19,"br")(20,"br"),t.TgZ(21,"p"),t._uU(22,"Angular 19 Output Implementation Approaches"),t.qZA(),t.TgZ(23,"ol",17)(24,"li")(25,"strong"),t._uU(26,"Traditional @Output Decorator"),t.qZA(),t._uU(27,": "),t.TgZ(28,"ul",18)(29,"li"),t._uU(30,"Uses the @Output() decorator combined with EventEmitter"),t.qZA(),t.TgZ(31,"li"),t._uU(32,"Remains fully supported in Angular 19 for backward compatibility"),t.qZA()(),t.TgZ(33,"button",19),t.NdJ("click",function(){t.CHM(e);const u=t.MAs(36);return t.KtG(u.hidden=!u.hidden)}),t._uU(34,"code"),t.qZA(),t.TgZ(35,"span",20,21)(37,"div",22)(38,"span"),t._uU(39,"typescript"),t.qZA(),t._UZ(40,"span",23),t.qZA(),t.TgZ(41,"pre"),t._uU(42,"          "),t.TgZ(43,"code",24),t._uU(44,"\n          "),t.qZA(),t._uU(45,"\n        "),t.qZA()()(),t.TgZ(46,"li")(47,"strong"),t._uU(48,"Output with Alias"),t.qZA(),t._uU(49,": "),t.TgZ(50,"ul",18)(51,"li"),t._uU(52,"Providing an alias name for the output allows for more intuitive template binding"),t.qZA(),t.TgZ(53,"li"),t._uU(54,"Useful when the public API naming differs from internal property names"),t.qZA()(),t.TgZ(55,"button",19),t.NdJ("click",function(){t.CHM(e);const u=t.MAs(58);return t.KtG(u.hidden=!u.hidden)}),t._uU(56,"code"),t.qZA(),t.TgZ(57,"span",20,25)(59,"div",22)(60,"span"),t._uU(61,"typescript"),t.qZA(),t._UZ(62,"span",23),t.qZA(),t.TgZ(63,"pre"),t._uU(64,"          "),t.TgZ(65,"code",24),t._uU(66,"\n          "),t.qZA(),t._uU(67,"\n        "),t.qZA()()(),t.TgZ(68,"li")(69,"strong"),t._uU(70,"Signal-Based Output (Angular 19)"),t.qZA(),t._uU(71,": "),t.TgZ(72,"ul",18)(73,"li"),t._uU(74,"New output() function as part of the signals API"),t.qZA(),t.TgZ(75,"li"),t._uU(76,"Provides a more concise way to define outputs"),t.qZA(),t.TgZ(77,"li"),t._uU(78,"Seamlessly integrates with other signal-based features"),t.qZA()(),t.TgZ(79,"button",19),t.NdJ("click",function(){t.CHM(e);const u=t.MAs(82);return t.KtG(u.hidden=!u.hidden)}),t._uU(80,"code"),t.qZA(),t.TgZ(81,"span",20,26)(83,"div",22)(84,"span"),t._uU(85,"typescript"),t.qZA(),t._UZ(86,"span",23),t.qZA(),t.TgZ(87,"pre"),t._uU(88,"          "),t.TgZ(89,"code",24),t._uU(90,"\n          "),t.qZA(),t._uU(91,"\n        "),t.qZA()()(),t.TgZ(92,"li")(93,"strong"),t._uU(94,"Using Outputs in Parent Components"),t.qZA(),t._uU(95,": "),t.TgZ(96,"ul",18)(97,"li"),t._uU(98,"Parent components can listen to outputs using event binding syntax"),t.qZA(),t.TgZ(99,"li"),t._uU(100,"Consistent approach for both traditional and signal-based outputs"),t.qZA()(),t.TgZ(101,"button",19),t.NdJ("click",function(){t.CHM(e);const u=t.MAs(104);return t.KtG(u.hidden=!u.hidden)}),t._uU(102,"code"),t.qZA(),t.TgZ(103,"span",20,27)(105,"div",22)(106,"span"),t._uU(107,"html"),t.qZA(),t._UZ(108,"span",23),t.qZA(),t.TgZ(109,"pre"),t._uU(110,"          "),t.TgZ(111,"code",24),t._uU(112,"\n          "),t.qZA(),t._uU(113,"\n        "),t.qZA()()()(),t._UZ(114,"br")(115,"br"),t.TgZ(116,"p"),t._uU(117,"Angular 19 Output Enhancements"),t.qZA(),t.TgZ(118,"ol",17)(119,"li")(120,"strong"),t._uU(121,"Signal-Based output() Function"),t.qZA(),t._uU(122,": "),t.TgZ(123,"ul",18)(124,"li"),t._uU(125,"Part of Angular's new signals API that provides a more reactive programming model"),t.qZA(),t.TgZ(126,"li"),t._uU(127,"More concise syntax compared to traditional @Output decorator with EventEmitter"),t.qZA(),t.TgZ(128,"li"),t._uU(129,"Better TypeScript inference and improved development experience"),t.qZA()()(),t.TgZ(130,"li")(131,"strong"),t._uU(132,"Improved Performance"),t.qZA(),t._uU(133,": "),t.TgZ(134,"ul",18)(135,"li"),t._uU(136,"Signal-based outputs are optimized for Angular's rendering pipeline"),t.qZA(),t.TgZ(137,"li"),t._uU(138,"Reduced memory footprint compared to traditional EventEmitter-based outputs"),t.qZA(),t.TgZ(139,"li"),t._uU(140,"Better integration with Angular's change detection mechanism"),t.qZA()()(),t.TgZ(141,"li")(142,"strong"),t._uU(143,"Better Developer Experience"),t.qZA(),t._uU(144,": "),t.TgZ(145,"ul",18)(146,"li"),t._uU(147,"Consistent API with other signal-based features (input(), model(), etc.)"),t.qZA(),t.TgZ(148,"li"),t._uU(149,"Improved type safety and autocompletion in IDEs"),t.qZA(),t.TgZ(150,"li"),t._uU(151,"More readable and maintainable code with less boilerplate"),t.qZA()()(),t.TgZ(152,"li")(153,"strong"),t._uU(154,"Zoneless Application Support"),t.qZA(),t._uU(155,": "),t.TgZ(156,"ul",18)(157,"li"),t._uU(158,"Designed to work efficiently in zoneless applications"),t.qZA(),t.TgZ(159,"li"),t._uU(160,"Better integration with Angular's new reactivity system"),t.qZA(),t.TgZ(161,"li"),t._uU(162,"Reduced reliance on Zone.js for change detection"),t.qZA()()()(),t._UZ(163,"br")(164,"br"),t.TgZ(165,"p"),t._uU(166,"Comparing Traditional vs Signal-Based Outputs"),t.qZA(),t._UZ(167,"br"),t.TgZ(168,"table",28)(169,"thead")(170,"tr",29)(171,"th",30),t._uU(172,"Traditional Approach"),t.qZA(),t.TgZ(173,"th",30),t._uU(174,"Signal-Based Approach (Angular 19)"),t.qZA()()(),t.TgZ(175,"tbody")(176,"tr",31)(177,"td",32)(178,"code"),t._uU(179,"@Output() changed = new EventEmitter<string>();"),t.qZA()(),t.TgZ(180,"td",32)(181,"code"),t._uU(182,"changed = output<string>();"),t.qZA()()(),t.TgZ(183,"tr",33)(184,"td",32)(185,"code"),t._uU(186,"@Output('valueChange') changed = new EventEmitter<number>();"),t.qZA()(),t.TgZ(187,"td",32)(188,"code"),t._uU(189,"changed = output<number>('valueChange');"),t.qZA()()(),t.TgZ(190,"tr",31)(191,"td",32)(192,"code"),t._uU(193,"this.changed.emit(value);"),t.qZA()(),t.TgZ(194,"td",32)(195,"code"),t._uU(196,"this.changed.emit(value);"),t.qZA()()(),t.TgZ(197,"tr",33)(198,"td",32),t._uU(199,"Requires explicit EventEmitter initialization"),t.qZA(),t.TgZ(200,"td",32),t._uU(201,"Automatically initializes the output"),t.qZA()()()()}if(2&n){const e=t.oxw();t.xp6(43),t.Q6J("highlight",e.code_1)("languages",t.DdM(8,l)),t.xp6(22),t.Q6J("highlight",e.code_2)("languages",t.DdM(9,l)),t.xp6(24),t.Q6J("highlight",e.code_3)("languages",t.DdM(10,l)),t.xp6(22),t.Q6J("highlight",e.code_4)("languages",t.DdM(11,k))}}function M(n,i){1&n&&(t.TgZ(0,"ol",34)(1,"li")(2,"strong",35),t._uU(3,"Use Descriptive Event Names"),t.qZA(),t.TgZ(4,"ul",18)(5,"li")(6,"strong"),t._uU(7,"Meaningful Names"),t.qZA(),t._uU(8,": Choose output names that clearly describe the event being emitted, such as 'itemAdded', 'statusChanged', or 'formSubmitted'. "),t.qZA(),t.TgZ(9,"li")(10,"strong"),t._uU(11,"Event-Like Naming"),t.qZA(),t._uU(12,": Use past-tense verb phrases for events that have already occurred, e.g., 'saved', 'deleted', 'uploaded'. "),t.qZA()()(),t.TgZ(13,"li")(14,"strong",35),t._uU(15,"Include Relevant Data"),t.qZA(),t._uU(16,": "),t.TgZ(17,"ul",18)(18,"li")(19,"strong"),t._uU(20,"Emit Meaningful Data"),t.qZA(),t._uU(21,": Include all relevant data that the parent component needs to handle the event properly. "),t.qZA(),t.TgZ(22,"li")(23,"strong"),t._uU(24,"Use TypeScript Types"),t.qZA(),t._uU(25,": Define clear interface types for complex event data to ensure type safety and improve developer experience. "),t.qZA()()(),t.TgZ(26,"li")(27,"strong",35),t._uU(28,"Manage Subscription Lifecycle"),t.qZA(),t._uU(29,": "),t.TgZ(30,"ul",18)(31,"li")(32,"strong"),t._uU(33,"Clean Up Subscriptions"),t.qZA(),t._uU(34,": When subscribing to outputs in code (rather than template bindings), ensure proper cleanup to prevent memory leaks. "),t.qZA(),t.TgZ(35,"li")(36,"strong"),t._uU(37,"Use takeUntilDestroyed"),t.qZA(),t._uU(38,": In Angular 19, leverage the takeUntilDestroyed operator for automatic subscription management. "),t.qZA()()(),t.TgZ(39,"li")(40,"strong",35),t._uU(41,"Prefer Signal-Based Approach"),t.qZA(),t._uU(42,": "),t.TgZ(43,"ul",18)(44,"li")(45,"strong"),t._uU(46,"Use output() Function"),t.qZA(),t._uU(47,": For new Angular 19 applications, prefer the signal-based output() function over the traditional @Output decorator. "),t.qZA(),t.TgZ(48,"li")(49,"strong"),t._uU(50,"Consider model() Function"),t.qZA(),t._uU(51,": For two-way binding scenarios, use the model() function that combines input and output functionality. "),t.qZA()()(),t.TgZ(52,"li")(53,"strong",35),t._uU(54,"Avoid Overusing Outputs"),t.qZA(),t._uU(55,": "),t.TgZ(56,"ul",18)(57,"li")(58,"strong"),t._uU(59,"Consider Service-Based Communication"),t.qZA(),t._uU(60,": For communication between distant components, consider using services or state management instead of chaining outputs. "),t.qZA(),t.TgZ(61,"li")(62,"strong"),t._uU(63,"Limit Output Count"),t.qZA(),t._uU(64,": If a component has too many outputs, it may be a sign that it should be refactored into smaller, more focused components. "),t.qZA()()()())}function S(n,i){1&n&&(t.TgZ(0,"div",36)(1,"div")(2,"p",37),t._uU(3,"Pros:"),t.qZA(),t.TgZ(4,"ul",16)(5,"li"),t._uU(6,"Enables child-to-parent component communication following Angular's unidirectional data flow"),t.qZA(),t.TgZ(7,"li"),t._uU(8,"Promotes component encapsulation and loose coupling between components"),t.qZA(),t.TgZ(9,"li"),t._uU(10,"Provides declarative event binding in templates for clear parent-child relationships"),t.qZA(),t.TgZ(11,"li"),t._uU(12,"New signal-based output() function offers more concise syntax with less boilerplate"),t.qZA(),t.TgZ(13,"li"),t._uU(14,"Signal-based outputs integrate seamlessly with other reactive features"),t.qZA(),t.TgZ(15,"li"),t._uU(16,"Improved performance in Angular 19 with better change detection integration"),t.qZA(),t.TgZ(17,"li"),t._uU(18,"Better TypeScript type safety and developer tooling support"),t.qZA()()(),t.TgZ(19,"div")(20,"p",37),t._uU(21,"Cons:"),t.qZA(),t.TgZ(22,"ul",16)(23,"li"),t._uU(24,'Can lead to "output chains" when events need to pass through multiple component levels'),t.qZA(),t.TgZ(25,"li"),t._uU(26,"Not ideal for communication between unrelated components or distant parts of the component tree"),t.qZA(),t.TgZ(27,"li"),t._uU(28,"Maintaining two syntaxes (@Output and output()) may increase learning curve for developers"),t.qZA(),t.TgZ(29,"li"),t._uU(30,"Transitioning existing codebases to signal-based outputs requires refactoring effort"),t.qZA(),t.TgZ(31,"li"),t._uU(32,"Overuse of outputs can make component interfaces overly complex"),t.qZA(),t.TgZ(33,"li"),t._uU(34,"Limited to parent-child communication patterns; doesn't solve all communication needs"),t.qZA(),t.TgZ(35,"li"),t._uU(36,"May require additional state management solutions for complex applications"),t.qZA()()()())}function N(n,i){1&n&&(t.TgZ(0,"div",38)(1,"div",39)(2,"p",40),t._uU(3,"Input"),t.qZA(),t.TgZ(4,"p",41),t._uU(5,"Pass data from parent to child components"),t.qZA()(),t.TgZ(6,"div",39)(7,"p",40),t._uU(8,"EventEmitter"),t.qZA(),t.TgZ(9,"p",41),t._uU(10,"The class used by traditional outputs to emit events"),t.qZA()(),t.TgZ(11,"div",39)(12,"p",40),t._uU(13,"Signal Functions"),t.qZA(),t.TgZ(14,"p",41),t._uU(15,"New API including input(), output(), and model() functions"),t.qZA()(),t.TgZ(16,"div",39)(17,"p",40),t._uU(18,"Component Communication"),t.qZA(),t.TgZ(19,"p",41),t._uU(20,"Various patterns for components to interact with each other"),t.qZA()(),t.TgZ(21,"div",39)(22,"p",40),t._uU(23,"Two-way Binding"),t.qZA(),t.TgZ(24,"p",41),t._uU(25,"Combining inputs and outputs for bidirectional data flow"),t.qZA()(),t.TgZ(26,"div",39)(27,"p",40),t._uU(28,"Unidirectional Data Flow"),t.qZA(),t.TgZ(29,"p",41),t._uU(30,"Angular's pattern of data flowing down and events flowing up"),t.qZA()()())}class p{constructor(){this.selectedTab=1,this.code_1="// Basic Output decorator usage\nimport { Component, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <div>\n      <h2>Count: {{ count }}</h2>\n      <button (click)=\"increment()\">Increment</button>\n      <button (click)=\"reset()\">Reset</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  @Output() countChanged = new EventEmitter<number>();\n\n  increment() {\n    this.count++;\n    this.countChanged.emit(this.count);\n  }\n\n  reset() {\n    this.count = 0;\n    this.countChanged.emit(this.count);\n  }\n}",this.code_2="// Output with alias\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-product',\n  template: `\n    <div class=\"product\">\n      <h3>{{ name }}</h3>\n      <p>Price: ${{ price }}</p>\n      <button (click)=\"addToCart()\">Add to Cart</button>\n    </div>\n  `\n})\nexport class ProductComponent {\n  @Input() name: string = '';\n  @Input() price: number = 0;\n\n  // Output with alias\n  @Output('itemAdded') addToCartEvent = new EventEmitter<{name: string, price: number}>();\n\n  addToCart() {\n    this.addToCartEvent.emit({name: this.name, price: this.price});\n  }\n}",this.code_3='// Signal-based output in Angular 19\nimport { Component, output } from \'@angular/core\';\n\n@Component({\n  selector: \'app-user-form\',\n  template: `\n    <form (ngSubmit)="submitForm()">\n      <div>\n        <label for="name">Name:</label>\n        <input id="name" [(ngModel)]="user.name" name="name" required>\n      </div>\n      <div>\n        <label for="email">Email:</label>\n        <input id="email" [(ngModel)]="user.email" name="email" required>\n      </div>\n      <button type="submit">Submit</button>\n    </form>\n  `\n})\nexport class UserFormComponent {\n  user = { name: \'\', email: \'\' };\n\n  // Angular 19 output() function\n  formSubmitted = output<{name: string, email: string}>();\n\n  submitForm() {\n    this.formSubmitted.emit({...this.user});\n  }\n}',this.code_4='// Using Output in parent component template\n<app-counter\n  (countChanged)="handleCountChange($event)">\n</app-counter>\n\n<app-product\n  [name]="product.name"\n  [price]="product.price"\n  (itemAdded)="handleItemAdded($event)">\n</app-product>\n\n<app-user-form\n  (formSubmitted)="handleFormSubmit($event)">\n</app-user-form>'}}p.\u0275fac=function(i){return new(i||p)},p.\u0275cmp=t.Xpm({type:p,selectors:[["app-output"]],viewQuery:function(i,e){if(1&i&&(t.Gf(m,5),t.Gf(Z,5),t.Gf(_,5),t.Gf(A,5),t.Gf(f,5),t.Gf(h,5),t.Gf(T,5),t.Gf(U,5)),2&i){let o;t.iGM(o=t.CRH())&&(e.code1=o.first),t.iGM(o=t.CRH())&&(e.code2=o.first),t.iGM(o=t.CRH())&&(e.code3=o.first),t.iGM(o=t.CRH())&&(e.code4=o.first),t.iGM(o=t.CRH())&&(e.notesRef=o.first),t.iGM(o=t.CRH())&&(e.bestRef=o.first),t.iGM(o=t.CRH())&&(e.prosConsRef=o.first),t.iGM(o=t.CRH())&&(e.topicsRef=o.first)}},decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"list-decimal","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],["code4",""],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"flex","flex-col","gap-4"],[1,"font-semibold","text-sky-400"],[1,"grid","grid-cols-2","gap-4","py-2"],[1,"p-4","border","border-gray-700","rounded-lg","hover:bg-gray-800","transition-colors"],[1,"font-medium","text-sky-400"],[1,"text-sm"]],template:function(i,e){1&i&&(t.TgZ(0,"section",0)(1,"p",1),t._uU(2," Output "),t.qZA(),t.TgZ(3,"div",2)(4,"p")(5,"span",3),t._uU(6,"Output"),t.qZA(),t._uU(7," in Angular 19 is a decorator that allows a component to emit events to its parent component. With the introduction of the output() function in Angular 19, developers can now create outputs using a more concise, signal-based approach that integrates seamlessly with other reactive features of the framework. "),t.qZA(),t._UZ(8,"br"),t.TgZ(9,"div",4)(10,"div",5)(11,"button",6),t.NdJ("click",function(){return e.selectedTab=1}),t._uU(12," Notes "),t.qZA(),t.TgZ(13,"button",6),t.NdJ("click",function(){return e.selectedTab=2}),t._uU(14," Best Practices "),t.qZA(),t.TgZ(15,"button",6),t.NdJ("click",function(){return e.selectedTab=3}),t._uU(16," Pros and Cons "),t.qZA(),t.TgZ(17,"button",6),t.NdJ("click",function(){return e.selectedTab=4}),t._uU(18," Related Topics "),t.qZA()(),t.TgZ(19,"div",7),t.ynx(20,8),t.YNc(21,q,2,1,"div",9),t.YNc(22,C,2,1,"div",9),t.YNc(23,w,2,1,"div",9),t.YNc(24,O,2,1,"div",10),t.BQk(),t.qZA()()()(),t.YNc(25,E,202,12,"ng-template",null,11,t.W1O),t.YNc(27,M,65,0,"ng-template",null,12,t.W1O),t.YNc(29,S,37,0,"ng-template",null,13,t.W1O),t.YNc(31,N,31,0,"ng-template",null,14,t.W1O)),2&i&&(t.xp6(11),t.ekj("text-rose-300",1===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",2===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",3===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",4===e.selectedTab),t.xp6(3),t.Q6J("ngSwitch",e.selectedTab),t.xp6(1),t.Q6J("ngSwitchCase",2),t.xp6(1),t.Q6J("ngSwitchCase",3),t.xp6(1),t.Q6J("ngSwitchCase",4))},dependencies:[s.tP,s.RF,s.n9,s.ED,d.y$],changeDetection:0});var R=a(529);const G=[{path:"",component:p}];class r{}r.\u0275fac=function(i){return new(i||r)},r.\u0275mod=t.oAB({type:r}),r.\u0275inj=t.cJS({imports:[s.ez,d._l,R.JF,g.Bz.forChild(G)]})}}]);