"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[870],{4870:(N,g,s)=>{s.r(g),s.d(g,{ObserverModule:()=>a});var l=s(6895),d=s(7178),e=s(8256),p=s(827);const b=["code1"],Z=["code2"],_=["code3"],m=["notesRef"],v=["bestRef"],h=["prosConsRef"],f=["topicsRef"];function A(t,n){1&t&&e.GkF(0)}function T(t,n){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,A,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const r=e.MAs(28);e.xp6(1),e.Q6J("ngTemplateOutlet",r)}}function U(t,n){1&t&&e.GkF(0)}function q(t,n){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,U,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const r=e.MAs(30);e.xp6(1),e.Q6J("ngTemplateOutlet",r)}}function y(t,n){1&t&&e.GkF(0)}function O(t,n){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,y,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const r=e.MAs(32);e.xp6(1),e.Q6J("ngTemplateOutlet",r)}}function x(t,n){1&t&&e.GkF(0)}function w(t,n){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,x,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const r=e.MAs(26);e.xp6(1),e.Q6J("ngTemplateOutlet",r)}}const u=function(){return["typescript"]};function C(t,n){if(1&t){const r=e.EpF();e.TgZ(0,"p"),e._uU(1,"What is an Observer?"),e.qZA(),e.TgZ(2,"ul",16)(3,"li")(4,"strong"),e._uU(5,"Core Interface"),e.qZA(),e._uU(6,": An Observer is an interface with three callback methods: next(), error(), and complete(). "),e.qZA(),e.TgZ(7,"li")(8,"strong"),e._uU(9,"Data Consumer"),e.qZA(),e._uU(10,": Observers consume data emitted by Observables and define how to react to various types of notifications. "),e.qZA(),e.TgZ(11,"li")(12,"strong"),e._uU(13,"Reactive Pattern"),e.qZA(),e._uU(14,": Part of the reactive programming pattern, Observers work hand-in-hand with Observables to create a publish-subscribe model. "),e.qZA(),e.TgZ(15,"li")(16,"strong"),e._uU(17,"Type Definition"),e.qZA(),e._uU(18,": In TypeScript, an Observer is defined with a generic type parameter that specifies the type of data it can receive. "),e.qZA()(),e._UZ(19,"br")(20,"br"),e.TgZ(21,"p"),e._uU(22,"Observer Structure and Implementation in Angular 19"),e.qZA(),e.TgZ(23,"ol",17)(24,"li")(25,"strong"),e._uU(26,"Basic Implementation"),e.qZA(),e._uU(27,": "),e.TgZ(28,"ul",18)(29,"li"),e._uU(30,"Observers can be implemented as objects with next, error, and complete callback methods."),e.qZA(),e.TgZ(31,"li"),e._uU(32,"Angular 19 improves type inference for Observers with better TypeScript integration."),e.qZA()(),e.TgZ(33,"button",19),e.NdJ("click",function(){e.CHM(r);const i=e.MAs(36);return e.KtG(i.hidden=!i.hidden)}),e._uU(34,"code"),e.qZA(),e.TgZ(35,"span",20,21)(37,"div",22)(38,"span"),e._uU(39,"typescript"),e.qZA(),e._UZ(40,"span",23),e.qZA(),e.TgZ(41,"pre"),e._uU(42,"          "),e.TgZ(43,"code",24),e._uU(44,"\n          "),e.qZA(),e._uU(45,"\n        "),e.qZA()()(),e.TgZ(46,"li")(47,"strong"),e._uU(48,"Callback Functions"),e.qZA(),e._uU(49,": "),e.TgZ(50,"ul",18)(51,"li"),e._uU(52,"In Angular 19, you can pass separate callback functions directly to the subscribe() method."),e.qZA(),e.TgZ(53,"li"),e._uU(54,"This approach offers more concise syntax while maintaining the Observer pattern."),e.qZA()(),e.TgZ(55,"button",19),e.NdJ("click",function(){e.CHM(r);const i=e.MAs(58);return e.KtG(i.hidden=!i.hidden)}),e._uU(56,"code"),e.qZA(),e.TgZ(57,"span",20,25)(59,"div",22)(60,"span"),e._uU(61,"typescript"),e.qZA(),e._UZ(62,"span",23),e.qZA(),e.TgZ(63,"pre"),e._uU(64,"          "),e.TgZ(65,"code",24),e._uU(66,"\n          "),e.qZA(),e._uU(67,"\n        "),e.qZA()()(),e.TgZ(68,"li")(69,"strong"),e._uU(70,"Partial Observers"),e.qZA(),e._uU(71,": "),e.TgZ(72,"ul",18)(73,"li"),e._uU(74,"Angular 19 with RxJS 8 provides improved handling of partial observers, where you implement only some of the callback methods."),e.qZA(),e.TgZ(75,"li"),e._uU(76,"Missing callbacks are replaced with no-op functions, ensuring proper error handling."),e.qZA()()(),e.TgZ(77,"li")(78,"strong"),e._uU(79,"Context-Aware Observers"),e.qZA(),e._uU(80,": "),e.TgZ(81,"ul",18)(82,"li"),e._uU(83,"Angular 19 introduces better context handling for observers, making them more effective in complex component architectures."),e.qZA(),e.TgZ(84,"li"),e._uU(85,"This is particularly important in zoneless applications where change detection is more explicitly controlled."),e.qZA()()(),e.TgZ(86,"li")(87,"strong"),e._uU(88,"Integration with HttpClient"),e.qZA(),e._uU(89,": "),e.TgZ(90,"ul",18)(91,"li"),e._uU(92,"Observers are commonly used with HttpClient to handle API responses, errors, and completion events."),e.qZA(),e.TgZ(93,"li"),e._uU(94,"Angular 19 enhances this pattern with improved error reporting and typing."),e.qZA()(),e.TgZ(95,"button",19),e.NdJ("click",function(){e.CHM(r);const i=e.MAs(98);return e.KtG(i.hidden=!i.hidden)}),e._uU(96,"code"),e.qZA(),e.TgZ(97,"span",20,26)(99,"div",22)(100,"span"),e._uU(101,"typescript"),e.qZA(),e._UZ(102,"span",23),e.qZA(),e.TgZ(103,"pre"),e._uU(104,"          "),e.TgZ(105,"code",24),e._uU(106,"\n          "),e.qZA(),e._uU(107,"\n        "),e.qZA()()()(),e._UZ(108,"br")(109,"br"),e.TgZ(110,"p"),e._uU(111,"Angular 19 Observer Enhancements"),e.qZA(),e.TgZ(112,"ol",17)(113,"li")(114,"strong"),e._uU(115,"Typed Observers"),e.qZA(),e._uU(116,": "),e.TgZ(117,"ul",18)(118,"li"),e._uU(119,"Angular 19 provides enhanced type safety for Observers with improved TypeScript 5.4 integration."),e.qZA(),e.TgZ(120,"li"),e._uU(121,"Better error detection at compile time for Observer usage."),e.qZA()()(),e.TgZ(122,"li")(123,"strong"),e._uU(124,"Signal Integration"),e.qZA(),e._uU(125,": "),e.TgZ(126,"ul",18)(127,"li"),e._uU(128,"Observers can be created from Angular Signals or can update Signals when receiving values."),e.qZA(),e.TgZ(129,"li"),e._uU(130,"This creates a bridge between the Observable and Signal reactivity systems."),e.qZA()()(),e.TgZ(131,"li")(132,"strong"),e._uU(133,"Performance Optimizations"),e.qZA(),e._uU(134,": "),e.TgZ(135,"ul",18)(136,"li"),e._uU(137,"Angular 19 optimizes Observer creation and handling, reducing memory overhead."),e.qZA(),e.TgZ(138,"li"),e._uU(139,"Better memory management through improved subscription lifecycle handling."),e.qZA()()(),e.TgZ(140,"li")(141,"strong"),e._uU(142,"Zoneless Support"),e.qZA(),e._uU(143,": "),e.TgZ(144,"ul",18)(145,"li"),e._uU(146,"Observers in Angular 19 are designed to work efficiently in zoneless applications."),e.qZA(),e.TgZ(147,"li"),e._uU(148,"They trigger change detection more efficiently when integrated with Angular's new reactive system."),e.qZA()()(),e.TgZ(149,"li")(150,"strong"),e._uU(151,"RxJS 8 Compatibility"),e.qZA(),e._uU(152,": "),e.TgZ(153,"ul",18)(154,"li"),e._uU(155,"Angular 19 Observers are fully compatible with RxJS 8, leveraging its improved performance and smaller footprint."),e.qZA(),e.TgZ(156,"li"),e._uU(157,"Better error handling and debugging capabilities through enhanced RxJS integration."),e.qZA()()()(),e._UZ(158,"br")(159,"br"),e.TgZ(160,"p"),e._uU(161,"Observer Pattern Implementation"),e.qZA(),e._UZ(162,"br"),e.TgZ(163,"table",27)(164,"thead")(165,"tr",28)(166,"th",29),e._uU(167,"Method"),e.qZA(),e.TgZ(168,"th",29),e._uU(169,"Purpose"),e.qZA()()(),e.TgZ(170,"tbody")(171,"tr",30)(172,"td",31)(173,"code"),e._uU(174,"next(value)"),e.qZA()(),e.TgZ(175,"td",31),e._uU(176,"Called when an Observable emits a new value"),e.qZA()(),e.TgZ(177,"tr",32)(178,"td",31)(179,"code"),e._uU(180,"error(err)"),e.qZA()(),e.TgZ(181,"td",31),e._uU(182,"Called when an Observable encounters an error"),e.qZA()(),e.TgZ(183,"tr",30)(184,"td",31)(185,"code"),e._uU(186,"complete()"),e.qZA()(),e.TgZ(187,"td",31),e._uU(188,"Called when an Observable completes and will not emit any more values"),e.qZA()()()()}if(2&t){const r=e.oxw();e.xp6(43),e.Q6J("highlight",r.code_1)("languages",e.DdM(6,u)),e.xp6(22),e.Q6J("highlight",r.code_2)("languages",e.DdM(7,u)),e.xp6(40),e.Q6J("highlight",r.code_3)("languages",e.DdM(8,u))}}function k(t,n){1&t&&(e.TgZ(0,"ol",33)(1,"li")(2,"strong",34),e._uU(3,"Design Organized Observers"),e.qZA(),e.TgZ(4,"ul",18)(5,"li")(6,"strong"),e._uU(7,"Keep Observers Simple"),e.qZA(),e._uU(8,": Design observers to have a single responsibility. Avoid complex logic inside observer callbacks that makes them difficult to test and maintain. "),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"Group Related Functionality"),e.qZA(),e._uU(12,": For complex scenarios, group related observer handling into service methods rather than inlining all logic in component callbacks. "),e.qZA()()(),e.TgZ(13,"li")(14,"strong",34),e._uU(15,"Handle Errors Properly"),e.qZA(),e.TgZ(16,"ul",18)(17,"li")(18,"strong"),e._uU(19,"Always Implement Error Handlers"),e.qZA(),e._uU(20,": Never leave error handling undefined in observers, as unhandled errors can cause application crashes and poor user experience. "),e.qZA(),e.TgZ(21,"li")(22,"strong"),e._uU(23,"Use Error Boundaries"),e.qZA(),e._uU(24,": Implement proper error boundaries and recovery strategies within error callbacks to prevent cascading failures. "),e.qZA()()(),e.TgZ(25,"li")(26,"strong",34),e._uU(27,"Manage Subscription Lifecycle"),e.qZA(),e.TgZ(28,"ul",18)(29,"li")(30,"strong"),e._uU(31,"Store Subscription References"),e.qZA(),e._uU(32,": When manually creating observers, always store the returned subscription to allow for proper cleanup. "),e.qZA(),e.TgZ(33,"li")(34,"strong"),e._uU(35,"Use takeUntilDestroyed()"),e.qZA(),e._uU(36,": In Angular 19, leverage the takeUntilDestroyed() operator from the rxjs-interop package to automatically handle subscription cleanup. "),e.qZA()()(),e.TgZ(37,"li")(38,"strong",34),e._uU(39,"Leverage Angular Integration"),e.qZA(),e.TgZ(40,"ul",18)(41,"li")(42,"strong"),e._uU(43,"Use the Async Pipe"),e.qZA(),e._uU(44,": Prefer the async pipe in templates when possible, as it automatically manages observer subscriptions and unsubscriptions. "),e.qZA(),e.TgZ(45,"li")(46,"strong"),e._uU(47,"Integrate with Signals"),e.qZA(),e._uU(48,": In Angular 19, consider using toSignal() to convert observable values to signals when needed for better integration with the reactive system. "),e.qZA()()()())}function S(t,n){1&t&&(e.TgZ(0,"div",35)(1,"div")(2,"p",36),e._uU(3,"Pros:"),e.qZA(),e.TgZ(4,"ul",16)(5,"li"),e._uU(6,"Provides a standardized interface for handling asynchronous data streams"),e.qZA(),e.TgZ(7,"li"),e._uU(8,"Enables separation of concerns between data production and consumption"),e.qZA(),e.TgZ(9,"li"),e._uU(10,"Supports comprehensive error handling with dedicated error callback"),e.qZA(),e.TgZ(11,"li"),e._uU(12,"Allows for completion notification to perform cleanup tasks"),e.qZA(),e.TgZ(13,"li"),e._uU(14,"Integrates seamlessly with Angular's HTTP client and forms modules"),e.qZA(),e.TgZ(15,"li"),e._uU(16,"Works well with Angular 19's signal-based reactivity system"),e.qZA(),e.TgZ(17,"li"),e._uU(18,"Enhances code organization by separating data handling logic"),e.qZA()()(),e.TgZ(19,"div")(20,"p",36),e._uU(21,"Cons:"),e.qZA(),e.TgZ(22,"ul",16)(23,"li"),e._uU(24,"Can lead to memory leaks if subscriptions aren't properly managed"),e.qZA(),e.TgZ(25,"li"),e._uU(26,"Requires understanding of reactive programming concepts"),e.qZA(),e.TgZ(27,"li"),e._uU(28,"Error handling is mandatory but often overlooked by developers"),e.qZA(),e.TgZ(29,"li"),e._uU(30,"Manual subscription management adds complexity to components"),e.qZA(),e.TgZ(31,"li"),e._uU(32,"May result in excessive callback nesting if not properly structured"),e.qZA(),e.TgZ(33,"li"),e._uU(34,"Testing observers often requires more complex setup than imperative code"),e.qZA(),e.TgZ(35,"li"),e._uU(36,"Learning curve for developers new to reactive programming paradigms"),e.qZA()()()())}function R(t,n){1&t&&(e.TgZ(0,"div",37)(1,"div",38)(2,"p",39),e._uU(3,"Observable"),e.qZA(),e.TgZ(4,"p",40),e._uU(5,"The source of data that Observer consumes"),e.qZA()(),e.TgZ(6,"div",38)(7,"p",39),e._uU(8,"Subscription"),e.qZA(),e.TgZ(9,"p",40),e._uU(10,"The connection between Observable and Observer"),e.qZA()(),e.TgZ(11,"div",38)(12,"p",39),e._uU(13,"RxJS"),e.qZA(),e.TgZ(14,"p",40),e._uU(15,"Reactive Extensions library that provides Observable and Observer interfaces"),e.qZA()(),e.TgZ(16,"div",38)(17,"p",39),e._uU(18,"Subject"),e.qZA(),e.TgZ(19,"p",40),e._uU(20,"Special type of Observable that is also an Observer"),e.qZA()(),e.TgZ(21,"div",38)(22,"p",39),e._uU(23,"Signals"),e.qZA(),e.TgZ(24,"p",40),e._uU(25,"Angular 19's alternative reactivity primitive that works alongside Observers"),e.qZA()(),e.TgZ(26,"div",38)(27,"p",39),e._uU(28,"Async Pipe"),e.qZA(),e.TgZ(29,"p",40),e._uU(30,"Angular pipe that subscribes to an Observable and manages its Observer"),e.qZA()()())}class c{constructor(){this.selectedTab=1,this.code_1="// Basic Observer implementation\nconst observer = {\n  next: value => console.log('Next:', value),\n  error: err => console.error('Error:', err),\n  complete: () => console.log('Complete!')\n};\n\n// Using the observer with an observable\nimport { of } from 'rxjs';\nconst observable = of(1, 2, 3);\nobservable.subscribe(observer);",this.code_2="// Observer as callback functions\nimport { Observable } from 'rxjs';\n\nconst observable = new Observable(subscriber => {\n  subscriber.next('Hello');\n  subscriber.next('World');\n  subscriber.complete();\n});\n\n// Pass separate callback functions for next, error, and complete\nobservable.subscribe(\n  value => console.log('Next:', value),\n  err => console.error('Error:', err),\n  () => console.log('Complete!')\n);",this.code_3="// Using an Observer with HttpClient\nimport { HttpClient } from '@angular/common/http';\nimport { Component, inject } from '@angular/core';\n\n@Component({\n  // Component metadata\n})\nexport class UserComponent {\n  private http = inject(HttpClient);\n\n  fetchUser(id: string) {\n    const observer = {\n      next: user => this.handleUser(user),\n      error: err => this.handleError(err),\n      complete: () => this.finishLoading()\n    };\n\n    this.http.get(`/api/users/${id}`).subscribe(observer);\n  }\n\n  private handleUser(user: any) {\n    // Process user data\n  }\n\n  private handleError(error: any) {\n    // Handle errors\n  }\n\n  private finishLoading() {\n    // Handle completion\n  }\n}"}}c.\u0275fac=function(n){return new(n||c)},c.\u0275cmp=e.Xpm({type:c,selectors:[["app-observer"]],viewQuery:function(n,r){if(1&n&&(e.Gf(b,5),e.Gf(Z,5),e.Gf(_,5),e.Gf(m,5),e.Gf(v,5),e.Gf(h,5),e.Gf(f,5)),2&n){let o;e.iGM(o=e.CRH())&&(r.code1=o.first),e.iGM(o=e.CRH())&&(r.code2=o.first),e.iGM(o=e.CRH())&&(r.code3=o.first),e.iGM(o=e.CRH())&&(r.notesRef=o.first),e.iGM(o=e.CRH())&&(r.bestRef=o.first),e.iGM(o=e.CRH())&&(r.prosConsRef=o.first),e.iGM(o=e.CRH())&&(r.topicsRef=o.first)}},decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"list-decimal","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"flex","flex-col","gap-4"],[1,"font-semibold","text-sky-400"],[1,"grid","grid-cols-2","gap-4","py-2"],[1,"p-4","border","border-gray-700","rounded-lg","hover:bg-gray-800","transition-colors"],[1,"font-medium","text-sky-400"],[1,"text-sm"]],template:function(n,r){1&n&&(e.TgZ(0,"section",0)(1,"p",1),e._uU(2," Observer "),e.qZA(),e.TgZ(3,"div",2)(4,"p")(5,"span",3),e._uU(6,"Observer"),e.qZA(),e._uU(7," in Angular 19 is a key interface in the ReactiveX (RxJS) library that defines how to receive and react to notifications from Observables. Observers are consumers of data streams that implement callback methods for handling the three types of Observable notifications: next (data), error, and completion. In Angular 19, Observers integrate seamlessly with Signals and provide enhanced type safety with RxJS 8. "),e.qZA(),e._UZ(8,"br"),e.TgZ(9,"div",4)(10,"div",5)(11,"button",6),e.NdJ("click",function(){return r.selectedTab=1}),e._uU(12," Notes "),e.qZA(),e.TgZ(13,"button",6),e.NdJ("click",function(){return r.selectedTab=2}),e._uU(14," Best Practices "),e.qZA(),e.TgZ(15,"button",6),e.NdJ("click",function(){return r.selectedTab=3}),e._uU(16," Pros and Cons "),e.qZA(),e.TgZ(17,"button",6),e.NdJ("click",function(){return r.selectedTab=4}),e._uU(18," Related Topics "),e.qZA()(),e.TgZ(19,"div",7),e.ynx(20,8),e.YNc(21,T,2,1,"div",9),e.YNc(22,q,2,1,"div",9),e.YNc(23,O,2,1,"div",9),e.YNc(24,w,2,1,"div",10),e.BQk(),e.qZA()()()(),e.YNc(25,C,189,9,"ng-template",null,11,e.W1O),e.YNc(27,k,49,0,"ng-template",null,12,e.W1O),e.YNc(29,S,37,0,"ng-template",null,13,e.W1O),e.YNc(31,R,31,0,"ng-template",null,14,e.W1O)),2&n&&(e.xp6(11),e.ekj("text-rose-300",1===r.selectedTab),e.xp6(2),e.ekj("text-rose-300",2===r.selectedTab),e.xp6(2),e.ekj("text-rose-300",3===r.selectedTab),e.xp6(2),e.ekj("text-rose-300",4===r.selectedTab),e.xp6(3),e.Q6J("ngSwitch",r.selectedTab),e.xp6(1),e.Q6J("ngSwitchCase",2),e.xp6(1),e.Q6J("ngSwitchCase",3),e.xp6(1),e.Q6J("ngSwitchCase",4))},dependencies:[l.tP,l.RF,l.n9,l.ED,p.y$],changeDetection:0});var M=s(529);const J=[{path:"",component:c}];class a{}a.\u0275fac=function(n){return new(n||a)},a.\u0275mod=e.oAB({type:a}),a.\u0275inj=e.cJS({imports:[l.ez,p._l,M.JF,d.Bz.forChild(J)]})}}]);