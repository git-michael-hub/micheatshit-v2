"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[436],{7436:(k,u,s)=>{s.r(u),s.d(u,{SignalsComponent:()=>l});var r=s(6895),c=s(827),d=s(8512),e=s(8256),p=s(529);const Z=["notesRef"],_=["bestRef"],m=["prosConsRef"],f=["topicsRef"];function A(n,i){1&n&&e.GkF(0)}function U(n,i){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,A,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(28);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function h(n,i){1&n&&e.GkF(0)}function T(n,i){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,h,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(30);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function q(n,i){1&n&&e.GkF(0)}function v(n,i){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,q,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(32);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}function y(n,i){1&n&&e.GkF(0)}function b(n,i){if(1&n&&(e.TgZ(0,"div"),e.YNc(1,y,1,0,"ng-container",15),e.qZA()),2&n){e.oxw();const t=e.MAs(26);e.xp6(1),e.Q6J("ngTemplateOutlet",t)}}const g=function(){return["typescript"]};function C(n,i){if(1&n){const t=e.EpF();e.TgZ(0,"p"),e._uU(1,"What are Angular Signals?"),e.qZA(),e.TgZ(2,"ul",16)(3,"li")(4,"strong"),e._uU(5,"Reactive Primitives"),e.qZA(),e._uU(6,": Angular Signals are reactive primitives that enable fine-grained tracking of state changes and dependencies between values. "),e.qZA(),e.TgZ(7,"li")(8,"strong"),e._uU(9,"Three Primary Signal Types"),e.qZA(),e._uU(10,": Signals come in three main types: writable signals, computed signals, and effects. "),e.qZA(),e.TgZ(11,"li")(12,"strong"),e._uU(13,"Declarative Reactivity"),e.qZA(),e._uU(14,": They enable a declarative approach to reactivity, where dependencies are automatically tracked and updates propagate efficiently. "),e.qZA(),e.TgZ(15,"li")(16,"strong"),e._uU(17,"Improved Performance"),e.qZA(),e._uU(18,": Angular 19 has significantly improved signal performance, making them suitable for even the most demanding applications. "),e.qZA()(),e._UZ(19,"br")(20,"br"),e.TgZ(21,"p"),e._uU(22,"Basic Signal Usage"),e.qZA(),e.TgZ(23,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(26);return e.KtG(o.hidden=!o.hidden)}),e._uU(24,"code"),e.qZA(),e.TgZ(25,"span",18,19)(27,"div",20)(28,"span"),e._uU(29,"typescript"),e.qZA(),e._UZ(30,"span",21),e.qZA(),e.TgZ(31,"pre"),e._uU(32,"      "),e.TgZ(33,"code",22),e._uU(34,"\n      "),e.qZA(),e._uU(35,"\n    "),e.qZA()(),e._UZ(36,"br")(37,"br"),e.TgZ(38,"p"),e._uU(39,"Signals in Components"),e.qZA(),e.TgZ(40,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(43);return e.KtG(o.hidden=!o.hidden)}),e._uU(41,"code"),e.qZA(),e.TgZ(42,"span",18,23)(44,"div",20)(45,"span"),e._uU(46,"typescript"),e.qZA(),e._UZ(47,"span",21),e.qZA(),e.TgZ(48,"pre"),e._uU(49,"      "),e.TgZ(50,"code",22),e._uU(51,"\n      "),e.qZA(),e._uU(52,"\n    "),e.qZA()(),e._UZ(53,"br")(54,"br"),e.TgZ(55,"p"),e._uU(56,"Advanced Signal Features"),e.qZA(),e.TgZ(57,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(60);return e.KtG(o.hidden=!o.hidden)}),e._uU(58,"code"),e.qZA(),e.TgZ(59,"span",18,24)(61,"div",20)(62,"span"),e._uU(63,"typescript"),e.qZA(),e._UZ(64,"span",21),e.qZA(),e.TgZ(65,"pre"),e._uU(66,"      "),e.TgZ(67,"code",22),e._uU(68,"\n      "),e.qZA(),e._uU(69,"\n    "),e.qZA()(),e._UZ(70,"br")(71,"br"),e.TgZ(72,"p"),e._uU(73,"Angular 19 Signal Enhancements"),e.qZA(),e.TgZ(74,"button",17),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(77);return e.KtG(o.hidden=!o.hidden)}),e._uU(75,"code"),e.qZA(),e.TgZ(76,"span",18,25)(78,"div",20)(79,"span"),e._uU(80,"typescript"),e.qZA(),e._UZ(81,"span",21),e.qZA(),e.TgZ(82,"pre"),e._uU(83,"      "),e.TgZ(84,"code",22),e._uU(85,"\n      "),e.qZA(),e._uU(86,"\n    "),e.qZA()(),e._UZ(87,"br")(88,"br"),e.TgZ(89,"p"),e._uU(90,"The Three Signal Types"),e.qZA(),e.TgZ(91,"table",26)(92,"thead")(93,"tr",27)(94,"th",28),e._uU(95,"Signal Type"),e.qZA(),e.TgZ(96,"th",28),e._uU(97,"Description"),e.qZA(),e.TgZ(98,"th",28),e._uU(99,"Key Methods"),e.qZA()()(),e.TgZ(100,"tbody")(101,"tr",29)(102,"td",30)(103,"strong"),e._uU(104,"Writable Signal"),e.qZA()(),e.TgZ(105,"td",30),e._uU(106,"Basic signal that can be directly updated"),e.qZA(),e.TgZ(107,"td",30)(108,"code"),e._uU(109,"signal()"),e.qZA(),e._uU(110,", "),e.TgZ(111,"code"),e._uU(112,"set()"),e.qZA(),e._uU(113,", "),e.TgZ(114,"code"),e._uU(115,"update()"),e.qZA(),e._uU(116,", "),e.TgZ(117,"code"),e._uU(118,"asReadonly()"),e.qZA()()(),e.TgZ(119,"tr",31)(120,"td",30)(121,"strong"),e._uU(122,"Computed Signal"),e.qZA()(),e.TgZ(123,"td",30),e._uU(124,"Derived signal that calculates its value from other signals"),e.qZA(),e.TgZ(125,"td",30)(126,"code"),e._uU(127,"computed()"),e.qZA()()(),e.TgZ(128,"tr",32)(129,"td",30)(130,"strong"),e._uU(131,"Effect"),e.qZA()(),e.TgZ(132,"td",30),e._uU(133,"Side effect that runs when its dependencies change"),e.qZA(),e.TgZ(134,"td",30)(135,"code"),e._uU(136,"effect()"),e.qZA(),e._uU(137,", cleanup function"),e.qZA()()()(),e._UZ(138,"br")(139,"br"),e.TgZ(140,"p"),e._uU(141,"Angular 19 Signal Improvements"),e.qZA(),e.TgZ(142,"ol",33)(143,"li")(144,"strong"),e._uU(145,"Signal-Based Component Model"),e.qZA(),e._uU(146,": "),e.TgZ(147,"ul",34)(148,"li"),e._uU(149,"Angular 19 introduces signal-based inputs, outputs, models, and queries for components"),e.qZA(),e.TgZ(150,"li"),e._uU(151,"Component inputs and outputs are now signal-based with "),e.TgZ(152,"code"),e._uU(153,"input()"),e.qZA(),e._uU(154," and "),e.TgZ(155,"code"),e._uU(156,"output()"),e.qZA()(),e.TgZ(157,"li"),e._uU(158,"Two-way binding with "),e.TgZ(159,"code"),e._uU(160,"model()"),e.qZA(),e._uU(161," for cleaner component communication"),e.qZA()()(),e.TgZ(162,"li")(163,"strong"),e._uU(164,"Performance Optimizations"),e.qZA(),e._uU(165,": "),e.TgZ(166,"ul",34)(167,"li"),e._uU(168,"Optimized signal implementation for faster change detection"),e.qZA(),e.TgZ(169,"li"),e._uU(170,"Reduced memory overhead for signal storage"),e.qZA(),e.TgZ(171,"li"),e._uU(172,"Better garbage collection integration for signal dependencies"),e.qZA()()(),e.TgZ(173,"li")(174,"strong"),e._uU(175,"Developer Experience"),e.qZA(),e._uU(176,": "),e.TgZ(177,"ul",34)(178,"li"),e._uU(179,"Improved type safety across all signal operations"),e.qZA(),e.TgZ(180,"li"),e._uU(181,"Better error messages for common signal usage mistakes"),e.qZA(),e.TgZ(182,"li"),e._uU(183,"Enhanced debugging support in Angular DevTools"),e.qZA()()(),e.TgZ(184,"li")(185,"strong"),e._uU(186,"Signal Utilities"),e.qZA(),e._uU(187,": "),e.TgZ(188,"ul",34)(189,"li")(190,"code"),e._uU(191,"asReadonly()"),e.qZA(),e._uU(192," method for creating read-only signals"),e.qZA(),e.TgZ(193,"li"),e._uU(194,"Custom equality functions for controlling signal change detection"),e.qZA(),e.TgZ(195,"li")(196,"code"),e._uU(197,"untracked()"),e.qZA(),e._uU(198," for preventing dependency tracking in computed signals"),e.qZA()()(),e.TgZ(199,"li")(200,"strong"),e._uU(201,"Integration with Zoneless Applications"),e.qZA(),e._uU(202,": "),e.TgZ(203,"ul",34)(204,"li"),e._uU(205,"Signals are the foundation for zoneless applications in Angular 19"),e.qZA(),e.TgZ(206,"li"),e._uU(207,"Provide automatic UI updates without relying on Zone.js"),e.qZA(),e.TgZ(208,"li"),e._uU(209,"Enable more predictable, fine-grained change detection"),e.qZA()()()()}if(2&n){const t=e.oxw();e.xp6(33),e.Q6J("highlight",t.basicSignalCode)("languages",e.DdM(8,g)),e.xp6(17),e.Q6J("highlight",t.signalComponentsCode)("languages",e.DdM(9,g)),e.xp6(17),e.Q6J("highlight",t.advancedSignalsCode)("languages",e.DdM(10,g)),e.xp6(17),e.Q6J("highlight",t.v19EnhancementsCode)("languages",e.DdM(11,g))}}function S(n,i){1&n&&(e.TgZ(0,"ol",35)(1,"li")(2,"strong",36),e._uU(3,"Signal State Design"),e.qZA(),e.TgZ(4,"ul",34)(5,"li")(6,"strong"),e._uU(7,"Keep Signal Granularity Appropriate"),e.qZA(),e._uU(8,": Create signals at the right level of granularity. Too fine-grained signals can lead to complexity, while too coarse can reduce the benefits of reactivity. "),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"Use Computed for Derived State"),e.qZA(),e._uU(12,": Always use computed signals for derived state rather than manually updating dependent values. This ensures your derived state stays in sync automatically. "),e.qZA(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Minimize Stateful Services"),e.qZA(),e._uU(16,": Move signals to components when possible and keep services stateless. When services need state, use signals to make that state reactive. "),e.qZA()()(),e.TgZ(17,"li")(18,"strong",36),e._uU(19,"Performance Optimization"),e.qZA(),e.TgZ(20,"ul",34)(21,"li")(22,"strong"),e._uU(23,"Avoid Deep Objects in Signals"),e.qZA(),e._uU(24,": Prefer flat state in signals. Deep nesting can make change detection less efficient and updates more complex. "),e.qZA(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Use untracked() Strategically"),e.qZA(),e._uU(28,": Use "),e.TgZ(29,"code"),e._uU(30,"untracked()"),e.qZA(),e._uU(31," to prevent unnecessary dependencies in computed signals when you need to access a signal's value without creating a dependency. "),e.qZA(),e.TgZ(32,"li")(33,"strong"),e._uU(34,"Custom Equality Functions"),e.qZA(),e._uU(35,": Use custom equality functions for complex objects to prevent unnecessary updates when actual values haven't changed. "),e.qZA()()(),e.TgZ(36,"li")(37,"strong",36),e._uU(38,"Effect Management"),e.qZA(),e.TgZ(39,"ul",34)(40,"li")(41,"strong"),e._uU(42,"Clean Up Effects"),e.qZA(),e._uU(43,": Always return cleanup functions from effects that subscribe to external resources or create timers to prevent memory leaks. "),e.qZA(),e.TgZ(44,"li")(45,"strong"),e._uU(46,"Keep Effects Focused"),e.qZA(),e._uU(47,": Effects should have a single responsibility. Prefer multiple small effects over one large effect with many dependencies. "),e.qZA(),e.TgZ(48,"li")(49,"strong"),e._uU(50,"Place Effects Appropriately"),e.qZA(),e._uU(51,": Define effects where their dependencies are defined, typically in component constructors or initialization methods. "),e.qZA()()(),e.TgZ(52,"li")(53,"strong",36),e._uU(54,"Component Integration"),e.qZA(),e.TgZ(55,"ul",34)(56,"li")(57,"strong"),e._uU(58,"Prefer Signal Inputs and Outputs"),e.qZA(),e._uU(59,": In Angular 19, use "),e.TgZ(60,"code"),e._uU(61,"input()"),e.qZA(),e._uU(62,", "),e.TgZ(63,"code"),e._uU(64,"output()"),e.qZA(),e._uU(65,", and "),e.TgZ(66,"code"),e._uU(67,"model()"),e.qZA(),e._uU(68," for component communications over the older decorator approach. "),e.qZA(),e.TgZ(69,"li")(70,"strong"),e._uU(71,"Use asReadonly() for API Design"),e.qZA(),e._uU(72,": Expose read-only signals to consumers when they shouldn't be able to modify the value directly. "),e.qZA(),e.TgZ(73,"li")(74,"strong"),e._uU(75,"Consider Signal Store for Complex State"),e.qZA(),e._uU(76,": For complex application state, consider using a pattern like signal-based stores to organize related state and behavior. "),e.qZA()()(),e.TgZ(77,"li")(78,"strong",36),e._uU(79,"Migration Strategy"),e.qZA(),e.TgZ(80,"ul",34)(81,"li")(82,"strong"),e._uU(83,"Incremental Adoption"),e.qZA(),e._uU(84,": Migrate to signals incrementally, focusing on areas with complex state management or performance issues first. "),e.qZA(),e.TgZ(85,"li")(86,"strong"),e._uU(87,"Combine with RxJS When Needed"),e.qZA(),e._uU(88,": Signals and RxJS can coexist. Use signals for UI state and component interaction, and RxJS for complex asynchronous operations. "),e.qZA(),e.TgZ(89,"li")(90,"strong"),e._uU(91,"Consider Future Patterns"),e.qZA(),e._uU(92,": Design your signal architecture with the future in mind, such as zoneless applications and signal-based components. "),e.qZA()()()())}function x(n,i){1&n&&(e.TgZ(0,"strong",36),e._uU(1," Pros: "),e.qZA(),e._UZ(2,"br"),e.TgZ(3,"ol",37)(4,"li")(5,"strong"),e._uU(6,"Fine-grained Reactivity"),e.qZA(),e.TgZ(7,"ul",34)(8,"li")(9,"span",3),e._uU(10,"Precise Dependency Tracking"),e.qZA(),e._uU(11,": Signals automatically track their dependencies, leading to more efficient updates and rendering. "),e.qZA(),e.TgZ(12,"li")(13,"span",3),e._uU(14,"Minimal Re-rendering"),e.qZA(),e._uU(15,": Only parts of the UI that depend on changed signals are updated, reducing unnecessary work. "),e.qZA(),e.TgZ(16,"li")(17,"span",3),e._uU(18,"Explicit Change Detection"),e.qZA(),e._uU(19,": Changes to signal values explicitly trigger updates, making application behavior more predictable. "),e.qZA()()(),e.TgZ(20,"li")(21,"strong"),e._uU(22,"Improved Performance"),e.qZA(),e.TgZ(23,"ul",34)(24,"li")(25,"span",3),e._uU(26,"Optimized Change Detection"),e.qZA(),e._uU(27,": Angular 19 signals significantly improve change detection efficiency compared to traditional mechanisms. "),e.qZA(),e.TgZ(28,"li")(29,"span",3),e._uU(30,"Memory Efficiency"),e.qZA(),e._uU(31,": Signals have minimal memory overhead compared to alternatives like RxJS Subjects. "),e.qZA(),e.TgZ(32,"li")(33,"span",3),e._uU(34,"Zone-free Operation"),e.qZA(),e._uU(35,": Signals enable zoneless applications, reducing overhead related to zone.js. "),e.qZA()()(),e.TgZ(36,"li")(37,"strong"),e._uU(38,"Better Developer Experience"),e.qZA(),e.TgZ(39,"ul",34)(40,"li")(41,"span",3),e._uU(42,"Simple API"),e.qZA(),e._uU(43,": Signals have a straightforward, functional API that's easy to understand and use. "),e.qZA(),e.TgZ(44,"li")(45,"span",3),e._uU(46,"Improved Type Safety"),e.qZA(),e._uU(47,": Signal operations are fully typed, providing excellent TypeScript integration. "),e.qZA(),e.TgZ(48,"li")(49,"span",3),e._uU(50,"Debugging Support"),e.qZA(),e._uU(51,": Angular DevTools offers enhanced debugging capabilities for signals in Angular 19. "),e.qZA()()(),e.TgZ(52,"li")(53,"strong"),e._uU(54,"Integration with Angular Ecosystem"),e.qZA(),e.TgZ(55,"ul",34)(56,"li")(57,"span",3),e._uU(58,"Signal-based Components"),e.qZA(),e._uU(59,": Angular 19 introduces a complete signal-based component model with signal inputs, outputs, and models. "),e.qZA(),e.TgZ(60,"li")(61,"span",3),e._uU(62,"Integration with Templates"),e.qZA(),e._uU(63,": Signal values can be used directly in templates and automatically update when signals change. "),e.qZA(),e.TgZ(64,"li")(65,"span",3),e._uU(66,"Works with Existing Code"),e.qZA(),e._uU(67,": Signals can be gradually adopted alongside existing Angular patterns. "),e.qZA()()()(),e._UZ(68,"br")(69,"br"),e.TgZ(70,"strong",36),e._uU(71," Cons: "),e.qZA(),e._UZ(72,"br"),e.TgZ(73,"ol",37)(74,"li")(75,"strong"),e._uU(76,"Learning Curve"),e.qZA(),e.TgZ(77,"ul",34)(78,"li")(79,"span",3),e._uU(80,"New Mental Model"),e.qZA(),e._uU(81,": Developers familiar with RxJS or traditional Angular change detection need to learn a new approach. "),e.qZA(),e.TgZ(82,"li")(83,"span",3),e._uU(84,"Signal Function Calls"),e.qZA(),e._uU(85,": The need to call signals as functions to get their values can be confusing for newcomers. "),e.qZA(),e.TgZ(86,"li")(87,"span",3),e._uU(88,"Reactive Thinking"),e.qZA(),e._uU(89,": Requires a shift to thinking reactively about dependencies and data flow. "),e.qZA()()(),e.TgZ(90,"li")(91,"strong"),e._uU(92,"Migration Challenges"),e.qZA(),e.TgZ(93,"ul",34)(94,"li")(95,"span",3),e._uU(96,"Mixed Code Bases"),e.qZA(),e._uU(97,": During migration, managing code that uses both signals and traditional patterns can be complex. "),e.qZA(),e.TgZ(98,"li")(99,"span",3),e._uU(100,"Refactoring Effort"),e.qZA(),e._uU(101,": Converting existing components and services to use signals requires significant effort. "),e.qZA(),e.TgZ(102,"li")(103,"span",3),e._uU(104,"Third-party Libraries"),e.qZA(),e._uU(105,": Not all third-party libraries support signals yet, creating potential integration challenges. "),e.qZA()()(),e.TgZ(106,"li")(107,"strong"),e._uU(108,"Debugging Complexity"),e.qZA(),e.TgZ(109,"ul",34)(110,"li")(111,"span",3),e._uU(112,"Hidden Dependencies"),e.qZA(),e._uU(113,": Automatic dependency tracking can sometimes make it difficult to trace exactly what's causing updates. "),e.qZA(),e.TgZ(114,"li")(115,"span",3),e._uU(116,"Effect Debugging"),e.qZA(),e._uU(117,": Effects with many dependencies can be challenging to debug when they trigger unexpectedly. "),e.qZA(),e.TgZ(118,"li")(119,"span",3),e._uU(120,"Stack Traces"),e.qZA(),e._uU(121,": Error stack traces from signal operations can sometimes be harder to follow than traditional code. "),e.qZA()()(),e.TgZ(122,"li")(123,"strong"),e._uU(124,"Potential Overuse"),e.qZA(),e.TgZ(125,"ul",34)(126,"li")(127,"span",3),e._uU(128,"Signal Proliferation"),e.qZA(),e._uU(129,": There's a risk of creating too many fine-grained signals, leading to unnecessarily complex code. "),e.qZA(),e.TgZ(130,"li")(131,"span",3),e._uU(132,"Architecture Decisions"),e.qZA(),e._uU(133,": Determining where to place signals (components vs. services) requires careful consideration. "),e.qZA(),e.TgZ(134,"li")(135,"span",3),e._uU(136,"Performance Overhead"),e.qZA(),e._uU(137,": While signals are optimized, there's still some overhead for very simple state changes that might not need reactivity. "),e.qZA()()()())}function w(n,i){1&n&&(e.TgZ(0,"ol",37)(1,"li")(2,"strong"),e._uU(3,"Signal-Based Components"),e.qZA(),e.TgZ(4,"ul",34)(5,"li")(6,"strong",36),e._uU(7,"Description"),e.qZA(),e._uU(8,": Angular 19's component model based entirely on signals, replacing traditional inputs and outputs. "),e.qZA(),e.TgZ(9,"li")(10,"strong",36),e._uU(11,"Relation to Signals"),e.qZA(),e._uU(12,": Uses signals as the foundation for component inputs, outputs, models, and queries, creating a unified reactive programming model. "),e.qZA()()(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Zoneless Applications"),e.qZA(),e.TgZ(16,"ul",34)(17,"li")(18,"strong",36),e._uU(19,"Description"),e.qZA(),e._uU(20,": Angular applications that operate without Zone.js, using signals and explicit change detection. "),e.qZA(),e.TgZ(21,"li")(22,"strong",36),e._uU(23,"Relation to Signals"),e.qZA(),e._uU(24,": Signals provide the reactivity mechanism that enables applications to function efficiently without Zone.js. "),e.qZA()()(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Reactive Programming"),e.qZA(),e.TgZ(28,"ul",34)(29,"li")(30,"strong",36),e._uU(31,"Description"),e.qZA(),e._uU(32,": Programming paradigm focused on data streams and propagation of change. "),e.qZA(),e.TgZ(33,"li")(34,"strong",36),e._uU(35,"Relation to Signals"),e.qZA(),e._uU(36,": Signals implement reactive programming principles in a way that's integrated with Angular's rendering system. "),e.qZA()()(),e.TgZ(37,"li")(38,"strong"),e._uU(39,"RxJS and Observables"),e.qZA(),e.TgZ(40,"ul",34)(41,"li")(42,"strong",36),e._uU(43,"Description"),e.qZA(),e._uU(44,": Library for reactive programming with Observables in Angular applications. "),e.qZA(),e.TgZ(45,"li")(46,"strong",36),e._uU(47,"Relation to Signals"),e.qZA(),e._uU(48,": Complementary to signals - RxJS is better for complex async operations, while signals excel at UI state management. "),e.qZA()()(),e.TgZ(49,"li")(50,"strong"),e._uU(51,"Change Detection"),e.qZA(),e.TgZ(52,"ul",34)(53,"li")(54,"strong",36),e._uU(55,"Description"),e.qZA(),e._uU(56,": How Angular identifies and propagates changes to update the DOM. "),e.qZA(),e.TgZ(57,"li")(58,"strong",36),e._uU(59,"Relation to Signals"),e.qZA(),e._uU(60,": Signals enable fine-grained change detection by creating explicit connections between state and UI. "),e.qZA()()(),e.TgZ(61,"li")(62,"strong"),e._uU(63,"Partial Hydration"),e.qZA(),e.TgZ(64,"ul",34)(65,"li")(66,"strong",36),e._uU(67,"Description"),e.qZA(),e._uU(68,": Technique to selectively hydrate server-rendered components based on priority or visibility. "),e.qZA(),e.TgZ(69,"li")(70,"strong",36),e._uU(71,"Relation to Signals"),e.qZA(),e._uU(72,": Signals integrate with partial hydration, enabling efficient state restoration when components are hydrated. "),e.qZA()()(),e.TgZ(73,"li")(74,"strong"),e._uU(75,"State Management"),e.qZA(),e.TgZ(76,"ul",34)(77,"li")(78,"strong",36),e._uU(79,"Description"),e.qZA(),e._uU(80,": Patterns and practices for managing application state in Angular applications. "),e.qZA(),e.TgZ(81,"li")(82,"strong",36),e._uU(83,"Relation to Signals"),e.qZA(),e._uU(84,": Signals provide a built-in mechanism for reactive state management that can replace or complement external libraries. "),e.qZA()()()())}class l extends d.Y{constructor(i){super(),this.http=i,this.selectedTab=1,this.basicSignalCode="import { signal, computed, effect } from '@angular/core';\n\n// Create a signal with an initial value\nconst count = signal(0);\n\n// Read the signal's value\nconsole.log(count()); // 0\n\n// Update the signal's value\ncount.set(5);\nconsole.log(count()); // 5\n\n// Update based on the previous value\ncount.update(value => value + 1);\nconsole.log(count()); // 6\n\n// Create a computed signal that depends on another signal\nconst doubled = computed(() => count() * 2);\nconsole.log(doubled()); // 12\n\n// Effect that runs when any of its dependencies change\neffect(() => {\n  console.log(`The count is ${count()} and doubled is ${doubled()}`);\n  // The count is 6 and doubled is 12\n});\n\n// When we update the count, the effect runs again automatically\ncount.set(10);\n// Effect logs: The count is 10 and doubled is 20",this.signalComponentsCode="import { Component, signal, computed, effect } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div>\n      <h2>Counter: {{ count() }}</h2>\n      <p>Doubled: {{ doubled() }}</p>\n      <button (click)=\"increment()\">Increment</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  // Signal for component state\n  count = signal(0);\n\n  // Computed signal derived from count\n  doubled = computed(() => count() * 2);\n\n  constructor() {\n    // Effect runs whenever count changes\n    effect(() => {\n      console.log(`Counter changed to ${this.count()}`);\n    });\n  }\n\n  increment() {\n    this.count.update(n => n + 1);\n  }\n}",this.advancedSignalsCode="import { signal, computed, effect, untracked, Signal } from '@angular/core';\n\n// 1. Signal with custom equality function\nconst user = signal({ name: 'Alice', age: 30 }, {\n  equal: (a, b) => a.name === b.name && a.age === b.age\n});\n\n// Now only changes to name or age will trigger updates\nuser.set({ name: 'Alice', age: 30 }); // No notifications\nuser.set({ name: 'Bob', age: 30 }); // Triggers updates\n\n// 2. Signal wrapping\n// Convert a value to a read-only signal\nfunction wrap<T>(value: T): Signal<T> {\n  const sig = signal(value);\n  return () => sig();\n}\n\nconst readOnly = wrap('hello');\nconsole.log(readOnly()); // 'hello'\n// readOnly.set('world'); // Error: readOnly is not a WritableSignal\n\n// 3. Untracked to prevent dependencies\nconst count = signal(0);\nconst name = signal('Alice');\n\nconst message = computed(() => {\n  // Only depends on count, not name\n  return `Count: ${count()}, User: ${untracked(() => name())}`;\n});\n\n// 4. Effect cleanup\neffect((onCleanup) => {\n  const intervalId = setInterval(() => {\n    console.log(count());\n  }, 1000);\n\n  // Cleanup function runs before the next effect execution\n  // or when the effect is destroyed\n  onCleanup(() => {\n    clearInterval(intervalId);\n  });\n});",this.v19EnhancementsCode="// Angular 19 Signal Enhancements\n\n// 1. Signal-based Component Inputs\nimport { Component, input, model } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<div>{{ name() }}</div>`\n})\nexport class UserCardComponent {\n  // Signal-based input with default value\n  name = input('Guest');\n\n  // Required input with type\n  userId = input.required<string>();\n\n  // Input with transform function\n  age = input(0, {\n    transform: (value: number) => Math.max(0, value)\n  });\n\n  // Two-way binding with model signal\n  isActive = model(false);\n}\n\n// 2. Read-only signals with asReadonly\nimport { signal } from '@angular/core';\n\nconst counter = signal(0);\n// Create a read-only version of the signal\nconst readonlyCounter = counter.asReadonly();\n\ncounter.update(v => v + 1); // Works fine\n// readonlyCounter.update(v => v + 1); // Error: no update method\n\n// 3. Improved type-safety\nimport { signal, computed, effect } from '@angular/core';\n\n// Signal generic types are properly preserved\nconst items = signal<string[]>([]);\nitems.update(arr => [...arr, 'new item']);\n\n// Type checking in computed values\nconst itemCount = computed(() => items().length);\n\n// Type inference in effects\neffect(() => {\n  const currentItems: string[] = items(); // Type is inferred correctly\n  console.log(`There are ${itemCount()} items`);\n});\n\n// 4. Enhanced Developer Experience\n// Better error messages for common mistakes\neffect(() => {\n  console.log(items); // Error: Signal accessed without being called\n  console.log(items()); // Correct: Call the signal to get its value\n});"}ngOnInit(){}}l.\u0275fac=function(i){return new(i||l)(e.Y36(p.eN))},l.\u0275cmp=e.Xpm({type:l,selectors:[["app-signals"]],viewQuery:function(i,t){if(1&i&&(e.Gf(Z,5),e.Gf(_,5),e.Gf(m,5),e.Gf(f,5)),2&i){let a;e.iGM(a=e.CRH())&&(t.notesRef=a.first),e.iGM(a=e.CRH())&&(t.bestRef=a.first),e.iGM(a=e.CRH())&&(t.prosConsRef=a.first),e.iGM(a=e.CRH())&&(t.topicsRef=a.first)}},standalone:!0,features:[e.qOj,e.jDz],decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],["code4",""],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"list-decimal","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"list-decimal","px-10","text-sm"]],template:function(i,t){1&i&&(e.TgZ(0,"section",0)(1,"p",1),e._uU(2," Signals "),e.qZA(),e.TgZ(3,"div",2)(4,"p")(5,"span",3),e._uU(6,"Signals"),e.qZA(),e._uU(7," in Angular are reactive primitives introduced in Angular 16 and enhanced in Angular 19. They provide a fine-grained reactivity system for tracking state changes, enabling more efficient rendering, improved change detection, and a more intuitive reactive programming model. "),e.qZA(),e._UZ(8,"br"),e.TgZ(9,"div",4)(10,"div",5)(11,"button",6),e.NdJ("click",function(){return t.selectedTab=1}),e._uU(12," Notes "),e.qZA(),e.TgZ(13,"button",6),e.NdJ("click",function(){return t.selectedTab=2}),e._uU(14," Best Practices "),e.qZA(),e.TgZ(15,"button",6),e.NdJ("click",function(){return t.selectedTab=3}),e._uU(16," Pros and Cons "),e.qZA(),e.TgZ(17,"button",6),e.NdJ("click",function(){return t.selectedTab=4}),e._uU(18," Related Topics "),e.qZA()(),e.TgZ(19,"div",7),e.ynx(20,8),e.YNc(21,U,2,1,"div",9),e.YNc(22,T,2,1,"div",9),e.YNc(23,v,2,1,"div",9),e.YNc(24,b,2,1,"div",10),e.BQk(),e.qZA()()()(),e.YNc(25,C,210,12,"ng-template",null,11,e.W1O),e.YNc(27,S,93,0,"ng-template",null,12,e.W1O),e.YNc(29,x,138,0,"ng-template",null,13,e.W1O),e.YNc(31,w,85,0,"ng-template",null,14,e.W1O)),2&i&&(e.xp6(11),e.ekj("text-rose-300",1===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",2===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",3===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",4===t.selectedTab),e.xp6(3),e.Q6J("ngSwitch",t.selectedTab),e.xp6(1),e.Q6J("ngSwitchCase",2),e.xp6(1),e.Q6J("ngSwitchCase",3),e.xp6(1),e.Q6J("ngSwitchCase",4))},dependencies:[r.ez,r.tP,r.RF,r.n9,r.ED,c._l,c.y$],styles:["p[_ngcontent-%COMP%]{margin:0}"]})}}]);