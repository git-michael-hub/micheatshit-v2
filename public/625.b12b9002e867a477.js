"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[625],{4625:(q,u,a)=>{a.r(u),a.d(u,{ClassFieldDecoratorComponent:()=>s});var d=a(6895),c=a(827),p=a(8512),e=a(8256);const g=["inputCodeEl"],Z=["outputCodeEl"],_=["viewChildCodeEl"],m=["hostBindingCodeEl"],h=["signalInputCodeEl"],l=function(){return["typescript"]};function A(i,r){if(1&i){const t=e.EpF();e.TgZ(0,"div")(1,"p"),e._uU(2,"Core Angular Class Field Decorators"),e.qZA(),e.TgZ(3,"ul",9)(4,"li")(5,"strong"),e._uU(6,"@Input()"),e.qZA(),e._uU(7,": Declares a property that can receive data from a parent component. "),e.TgZ(8,"ul",10)(9,"li"),e._uU(10,"Enables component property binding"),e.qZA(),e.TgZ(11,"li"),e._uU(12,"Can include aliases, required flag, and transform functions"),e.qZA(),e.TgZ(13,"li"),e._uU(14,"Angular 19 introduces more robust typing and validation"),e.qZA(),e.TgZ(15,"button",11),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(18);return e.KtG(o.hidden=!o.hidden)}),e._uU(16,"code"),e.qZA(),e.TgZ(17,"span",12,13)(19,"div",14)(20,"span"),e._uU(21,"typescript"),e.qZA(),e._UZ(22,"span",15),e.qZA(),e.TgZ(23,"pre"),e._uU(24,"                    "),e._UZ(25,"code",16),e._uU(26,"\n                  "),e.qZA()()()(),e.TgZ(27,"li")(28,"strong"),e._uU(29,"@Output()"),e.qZA(),e._uU(30,": Declares an event emitter property that a component can use to emit events. "),e.TgZ(31,"ul",10)(32,"li"),e._uU(33,"Uses EventEmitter to emit custom events to parent components"),e.qZA(),e.TgZ(34,"li"),e._uU(35,"Can specify alias for clearer template binding"),e.qZA(),e.TgZ(36,"li"),e._uU(37,"Facilitates component communication"),e.qZA(),e.TgZ(38,"button",11),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(41);return e.KtG(o.hidden=!o.hidden)}),e._uU(39,"code"),e.qZA(),e.TgZ(40,"span",12,17)(42,"div",14)(43,"span"),e._uU(44,"typescript"),e.qZA(),e._UZ(45,"span",15),e.qZA(),e.TgZ(46,"pre"),e._uU(47,"                    "),e._UZ(48,"code",16),e._uU(49,"\n                  "),e.qZA()()()(),e.TgZ(50,"li")(51,"strong"),e._uU(52,"@ViewChild() / @ViewChildren()"),e.qZA(),e._uU(53,": Provides access to child elements, components, or directives in templates. "),e.TgZ(54,"ul",10)(55,"li"),e._uU(56,"Queries the DOM for elements matching a selector"),e.qZA(),e.TgZ(57,"li"),e._uU(58,"Can target template reference variables, component types, or directives"),e.qZA(),e.TgZ(59,"li"),e._uU(60,"Supports static query option for early access in ngOnInit"),e.qZA(),e.TgZ(61,"button",11),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(64);return e.KtG(o.hidden=!o.hidden)}),e._uU(62,"code"),e.qZA(),e.TgZ(63,"span",12,18)(65,"div",14)(66,"span"),e._uU(67,"typescript"),e.qZA(),e._UZ(68,"span",15),e.qZA(),e.TgZ(69,"pre"),e._uU(70,"                    "),e._UZ(71,"code",16),e._uU(72,"\n                  "),e.qZA()()()(),e.TgZ(73,"li")(74,"strong"),e._uU(75,"@HostBinding() / @HostListener()"),e.qZA(),e._uU(76,": Binds properties and events of the host element. "),e.TgZ(77,"ul",10)(78,"li"),e._uU(79,"@HostBinding binds to properties, attributes, or classes of the host element"),e.qZA(),e.TgZ(80,"li"),e._uU(81,"@HostListener subscribes to events on the host element"),e.qZA(),e.TgZ(82,"li"),e._uU(83,"Useful for directive implementation"),e.qZA(),e.TgZ(84,"button",11),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(87);return e.KtG(o.hidden=!o.hidden)}),e._uU(85,"code"),e.qZA(),e.TgZ(86,"span",12,19)(88,"div",14)(89,"span"),e._uU(90,"typescript"),e.qZA(),e._UZ(91,"span",15),e.qZA(),e.TgZ(92,"pre"),e._uU(93,"                    "),e._UZ(94,"code",16),e._uU(95,"\n                  "),e.qZA()()()()(),e._UZ(96,"br")(97,"br"),e.TgZ(98,"p"),e._uU(99,"Angular 19 Signal-Based Alternatives"),e.qZA(),e.TgZ(100,"ul",9)(101,"li")(102,"strong"),e._uU(103,"Signal-Based Inputs and Outputs"),e.qZA(),e._uU(104,": "),e.TgZ(105,"ul",10)(106,"li"),e._uU(107,"input() function replaces @Input() decorator"),e.qZA(),e.TgZ(108,"li"),e._uU(109,"output() function replaces @Output() decorator"),e.qZA(),e.TgZ(110,"li"),e._uU(111,"model() function provides two-way binding capability"),e.qZA(),e.TgZ(112,"li"),e._uU(113,"Improved type safety and runtime validation"),e.qZA(),e.TgZ(114,"li"),e._uU(115,"Better tree-shaking and performance optimization"),e.qZA(),e.TgZ(116,"button",11),e.NdJ("click",function(){e.CHM(t);const o=e.MAs(119);return e.KtG(o.hidden=!o.hidden)}),e._uU(117,"code"),e.qZA(),e.TgZ(118,"span",12,20)(120,"div",14)(121,"span"),e._uU(122,"typescript"),e.qZA(),e._UZ(123,"span",15),e.qZA(),e.TgZ(124,"pre"),e._uU(125,"                    "),e._UZ(126,"code",16),e._uU(127,"\n                  "),e.qZA()()()(),e.TgZ(128,"li")(129,"strong"),e._uU(130,"Key Advantages of Signal-Based APIs"),e.qZA(),e._uU(131,": "),e.TgZ(132,"ul",10)(133,"li"),e._uU(134,"Improved reactivity with direct signal integration"),e.qZA(),e.TgZ(135,"li"),e._uU(136,"Enhanced type checking with generics"),e.qZA(),e.TgZ(137,"li"),e._uU(138,"More intuitive API for transform functions"),e.qZA(),e.TgZ(139,"li"),e._uU(140,"Simpler syntax for declaring required inputs"),e.qZA(),e.TgZ(141,"li"),e._uU(142,"Better performance through optimization"),e.qZA()()()(),e._UZ(143,"br")(144,"br"),e.TgZ(145,"p"),e._uU(146,"Other Important Class Field Decorators"),e.qZA(),e.TgZ(147,"table",21)(148,"thead")(149,"tr",22)(150,"th",23),e._uU(151,"Decorator"),e.qZA(),e.TgZ(152,"th",23),e._uU(153,"Purpose"),e.qZA(),e.TgZ(154,"th",23),e._uU(155,"Angular 19 Status"),e.qZA()()(),e.TgZ(156,"tbody")(157,"tr",24)(158,"td",25),e._uU(159,"@ContentChild / @ContentChildren"),e.qZA(),e.TgZ(160,"td",25),e._uU(161,"Access projected content"),e.qZA(),e.TgZ(162,"td",25),e._uU(163,"Supported, no signal alternative yet"),e.qZA()(),e.TgZ(164,"tr",26)(165,"td",25),e._uU(166,"@Inject"),e.qZA(),e.TgZ(167,"td",25),e._uU(168,"Field-based DI token injection"),e.qZA(),e.TgZ(169,"td",25),e._uU(170,"Supported, functional inject() alternative available"),e.qZA()(),e.TgZ(171,"tr",24)(172,"td",25),e._uU(173,"@Optional"),e.qZA(),e.TgZ(174,"td",25),e._uU(175,"Mark dependencies as optional"),e.qZA(),e.TgZ(176,"td",25),e._uU(177,"Supported"),e.qZA()(),e.TgZ(178,"tr",26)(179,"td",25),e._uU(180,"@Self / @SkipSelf"),e.qZA(),e.TgZ(181,"td",25),e._uU(182,"Control injector hierarchy traversal"),e.qZA(),e.TgZ(183,"td",25),e._uU(184,"Supported"),e.qZA()(),e.TgZ(185,"tr",24)(186,"td",25),e._uU(187,"@Attribute"),e.qZA(),e.TgZ(188,"td",25),e._uU(189,"Access host element attribute values"),e.qZA(),e.TgZ(190,"td",25),e._uU(191,"Supported"),e.qZA()()()()()}if(2&i){const t=e.oxw();e.xp6(25),e.Q6J("highlight",t.inputCode)("languages",e.DdM(10,l)),e.xp6(23),e.Q6J("highlight",t.outputCode)("languages",e.DdM(11,l)),e.xp6(23),e.Q6J("highlight",t.viewChildCode)("languages",e.DdM(12,l)),e.xp6(23),e.Q6J("highlight",t.hostBindingCode)("languages",e.DdM(13,l)),e.xp6(32),e.Q6J("highlight",t.signalInputCode)("languages",e.DdM(14,l))}}function T(i,r){1&i&&(e.TgZ(0,"div")(1,"ol",27)(2,"li")(3,"strong",28),e._uU(4,"Use Descriptive Property Names"),e.qZA(),e.TgZ(5,"ul",10)(6,"li"),e._uU(7,"Choose clear, descriptive names for decorated properties"),e.qZA(),e.TgZ(8,"li"),e._uU(9,"Use camelCase for property names, following TypeScript conventions"),e.qZA(),e.TgZ(10,"li"),e._uU(11,"If using an alias, ensure it's intuitive for template consumers"),e.qZA(),e.TgZ(12,"li"),e._uU(13,"Document complex properties with JSDoc comments"),e.qZA()()(),e.TgZ(14,"li")(15,"strong",28),e._uU(16,"Prefer Signal-Based Inputs in Angular 19"),e.qZA(),e.TgZ(17,"ul",10)(18,"li"),e._uU(19,"Use input() function instead of @Input() decorator for new components"),e.qZA(),e.TgZ(20,"li"),e._uU(21,"Take advantage of improved type safety with generics"),e.qZA(),e.TgZ(22,"li"),e._uU(23,"Implement transform functions for data sanitization"),e.qZA(),e.TgZ(24,"li"),e._uU(25,"Use input.required<T>() for mandatory properties"),e.qZA(),e.TgZ(26,"li"),e._uU(27,"Consider model() for two-way binding scenarios"),e.qZA()()(),e.TgZ(28,"li")(29,"strong",28),e._uU(30,"Properly Type All Inputs and Outputs"),e.qZA(),e.TgZ(31,"ul",10)(32,"li"),e._uU(33,"Always specify types for Input and Output properties"),e.qZA(),e.TgZ(34,"li"),e._uU(35,"Use generic types with EventEmitter: EventEmitter<T>"),e.qZA(),e.TgZ(36,"li"),e._uU(37,"Avoid the any type; use unknown if the type is truly dynamic"),e.qZA(),e.TgZ(38,"li"),e._uU(39,"Consider using interface or type alias for complex data structures"),e.qZA(),e.TgZ(40,"li"),e._uU(41,"Use readonly arrays or objects when appropriate"),e.qZA()()(),e.TgZ(42,"li")(43,"strong",28),e._uU(44,"Optimize ViewChild and ContentChild Queries"),e.qZA(),e.TgZ(45,"ul",10)(46,"li"),e._uU(47),e.qZA(),e.TgZ(48,"li"),e._uU(49,"Specify the read option when querying for a specific token"),e.qZA(),e.TgZ(50,"li"),e._uU(51,"Be aware of timing differences between static and dynamic queries"),e.qZA(),e.TgZ(52,"li"),e._uU(53,"Use @ViewChildren with QueryList for multiple elements"),e.qZA(),e.TgZ(54,"li"),e._uU(55,"Remember that ContentChild queries elements projected from parent templates"),e.qZA()()(),e.TgZ(56,"li")(57,"strong",28),e._uU(58,"Implement Change Detection Strategies"),e.qZA(),e.TgZ(59,"ul",10)(60,"li"),e._uU(61,"Use OnPush change detection for improved performance"),e.qZA(),e.TgZ(62,"li"),e._uU(63,"Understand how inputs trigger change detection"),e.qZA(),e.TgZ(64,"li"),e._uU(65,"Consider immutable data patterns for OnPush components"),e.qZA(),e.TgZ(66,"li"),e._uU(67,"Use signal-based inputs for automatic fine-grained updates"),e.qZA(),e.TgZ(68,"li"),e._uU(69,"Be cautious with HostBinding in performance-critical components"),e.qZA()()()()()),2&i&&(e.xp6(47),e.AsE("Use ","{"," static: true ","}"," only when needed in ngOnInit"))}function U(i,r){1&i&&(e.TgZ(0,"div")(1,"div",29)(2,"p",30),e._uU(3,"Advantages of Class Field Decorators"),e.qZA(),e.TgZ(4,"ul",31)(5,"li")(6,"strong"),e._uU(7,"Declarative API"),e.qZA(),e._uU(8,": Clearly identifies the purpose and behavior of properties"),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"Simplified Component Communication"),e.qZA(),e._uU(12,": Easy to implement parent-child data flow"),e.qZA(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"DOM Integration"),e.qZA(),e._uU(16,": Provides direct access to template elements and DOM events"),e.qZA(),e.TgZ(17,"li")(18,"strong"),e._uU(19,"Type Safety"),e.qZA(),e._uU(20,": Works well with TypeScript's type system"),e.qZA(),e.TgZ(21,"li")(22,"strong"),e._uU(23,"Template Integration"),e.qZA(),e._uU(24,": Makes binding in templates intuitive and straightforward"),e.qZA(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Framework Integration"),e.qZA(),e._uU(28,": Ensures Angular can properly process components"),e.qZA(),e.TgZ(29,"li")(30,"strong"),e._uU(31,"Metadata Preservation"),e.qZA(),e._uU(32,": Retains information through the build process"),e.qZA()(),e.TgZ(33,"p",30),e._uU(34,"Challenges with Class Field Decorators"),e.qZA(),e.TgZ(35,"ul",31)(36,"li")(37,"strong"),e._uU(38,"TypeScript Experimental Feature"),e.qZA(),e._uU(39,": Decorators are still technically experimental"),e.qZA(),e.TgZ(40,"li")(41,"strong"),e._uU(42,"Performance Overhead"),e.qZA(),e._uU(43,": Traditional decorators add some runtime cost"),e.qZA(),e.TgZ(44,"li")(45,"strong"),e._uU(46,"Debugging Complexity"),e.qZA(),e._uU(47,": Errors in decorators can be harder to diagnose"),e.qZA(),e.TgZ(48,"li")(49,"strong"),e._uU(50,"Change Detection Complexity"),e.qZA(),e._uU(51,": Can trigger unnecessary renders if not careful"),e.qZA(),e.TgZ(52,"li")(53,"strong"),e._uU(54,"Timing Issues"),e.qZA(),e._uU(55,": ViewChild and ContentChild queries have specific lifecycle timing"),e.qZA(),e.TgZ(56,"li")(57,"strong"),e._uU(58,"Migration Effort"),e.qZA(),e._uU(59,": Moving to signal-based alternatives requires refactoring"),e.qZA(),e.TgZ(60,"li")(61,"strong"),e._uU(62,"Testing Complexity"),e.qZA(),e._uU(63,": Some decorators require special handling in tests"),e.qZA()(),e.TgZ(64,"p",30),e._uU(65,"Traditional vs. Angular 19 Signal-Based Patterns"),e.qZA(),e.TgZ(66,"table",32)(67,"thead")(68,"tr",22)(69,"th",23),e._uU(70,"Traditional Pattern"),e.qZA(),e.TgZ(71,"th",23),e._uU(72,"Angular 19 Signal-Based Pattern"),e.qZA()()(),e.TgZ(73,"tbody")(74,"tr",33)(75,"td",25),e._uU(76,"@Input() name: string;"),e.qZA(),e.TgZ(77,"td",25),e._uU(78,"name = input<string>('');"),e.qZA()(),e.TgZ(79,"tr",34)(80,"td",25),e._uU(81),e.qZA(),e.TgZ(82,"td",25),e._uU(83,"id = input.required<string>();"),e.qZA()(),e.TgZ(84,"tr",33)(85,"td",25),e._uU(86),e.qZA(),e.TgZ(87,"td",25),e._uU(88),e.qZA()(),e.TgZ(89,"tr",34)(90,"td",25),e._uU(91,"@Output() changed = new EventEmitter<T>();"),e.qZA(),e.TgZ(92,"td",25),e._uU(93,"changed = output<T>();"),e.qZA()(),e.TgZ(94,"tr",33)(95,"td",25),e._uU(96,"@Input() value: T;"),e._UZ(97,"br"),e._uU(98,"@Output() valueChange = new EventEmitter<T>();"),e.qZA(),e.TgZ(99,"td",25),e._uU(100,"value = model<T>(defaultValue);"),e.qZA()()()()()()),2&i&&(e.xp6(81),e.AsE("@Input(","{"," required: true ","}",") id!: string;"),e.xp6(5),e.AsE("@Input(","{"," transform: fn ","}",") value: T;"),e.xp6(2),e.AsE("value = input<T>(defaultValue, ","{"," transform: fn ","}",");"))}function f(i,r){1&i&&(e.TgZ(0,"div")(1,"div",29)(2,"p",30),e._uU(3,"Related Angular Concepts"),e.qZA(),e.TgZ(4,"ul",31)(5,"li")(6,"strong"),e._uU(7,"Component Communication"),e.qZA(),e._uU(8,": How data flows between components in Angular"),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"TypeScript Decorators"),e.qZA(),e._uU(12,": The language feature that enables Angular's field decorators"),e.qZA(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Angular Signals"),e.qZA(),e._uU(16,": The reactive primitive that powers modern input/output APIs"),e.qZA(),e.TgZ(17,"li")(18,"strong"),e._uU(19,"Change Detection"),e.qZA(),e._uU(20,": How decorated properties affect Angular's update cycle"),e.qZA(),e.TgZ(21,"li")(22,"strong"),e._uU(23,"Component Lifecycle"),e.qZA(),e._uU(24,": How ViewChild and ContentChild queries interact with lifecycle hooks"),e.qZA()(),e.TgZ(25,"p",30),e._uU(26,"Class Field Decorator FAQ"),e.qZA(),e.TgZ(27,"ul",31)(28,"li")(29,"strong"),e._uU(30,"Q: Should I use traditional decorators or signal-based APIs in Angular 19?"),e.qZA(),e._UZ(31,"br"),e._uU(32," A: For new components, prefer signal-based APIs (input(), output(), model()). They offer better performance, type safety, and integration with Angular's reactivity system. For existing components, consider migrating during major refactors. "),e.qZA(),e.TgZ(33,"li")(34,"strong"),e._uU(35,"Q: When should I use ViewChild vs ContentChild?"),e.qZA(),e._UZ(36,"br"),e._uU(37," A: Use ViewChild to access elements defined in the component's own template. Use ContentChild to access elements projected into the component via ng-content. "),e.qZA(),e.TgZ(38,"li")(39,"strong"),e._uU(40,"Q: How do I handle required inputs in Angular 19?"),e.qZA(),e._UZ(41,"br"),e._uU(42),e.qZA(),e.TgZ(43,"li")(44,"strong"),e._uU(45,"Q: Can I transform input values in Angular 19?"),e.qZA(),e._UZ(46,"br"),e._uU(47),e.qZA(),e.TgZ(48,"li")(49,"strong"),e._uU(50,"Q: How do signal-based inputs affect change detection?"),e.qZA(),e._UZ(51,"br"),e._uU(52," A: Signal-based inputs integrate with Angular's fine-grained reactivity system, potentially reducing unnecessary re-renders and improving performance. "),e.qZA()(),e.TgZ(53,"p",30),e._uU(54,"Useful Resources"),e.qZA(),e.TgZ(55,"ul",10)(56,"li")(57,"a",35),e._uU(58,"Angular Input Binding Guide"),e.qZA()(),e.TgZ(59,"li")(60,"a",36),e._uU(61,"Angular Output Binding Guide"),e.qZA()(),e.TgZ(62,"li")(63,"a",37),e._uU(64,"Component View Encapsulation"),e.qZA()(),e.TgZ(65,"li")(66,"a",38),e._uU(67,"Angular Signals Guide"),e.qZA()(),e.TgZ(68,"li")(69,"a",39),e._uU(70,"TypeScript Decorators Documentation"),e.qZA()()()()()),2&i&&(e.xp6(42),e.AsE(" A: With traditional decorators, use @Input(","{"," required: true ","}","). With signal-based APIs, use input.required<T>(). "),e.xp6(5),e.HOy(" A: Yes, both @Input(","{"," transform: fn ","}",") and input(defaultValue, ","{"," transform: fn ","}",") support transformation functions that process values before they reach the component. "))}class s extends p.Y{constructor(){super(...arguments),this.selectedTab=1,this.inputCode="// Traditional @Input decorator\n@Component({\n  selector: 'app-user-profile',\n  template: `\n    <div class=\"user-card\">\n      <h2>{{ name }}</h2>\n      <div>Age: {{ age }}</div>\n    </div>\n  `\n})\nexport class UserProfileComponent {\n  @Input() name: string = '';\n\n  // Input with alias\n  @Input('userAge') age: number = 0;\n\n  // Required input (Angular 14+)\n  @Input({ required: true }) userId!: string;\n\n  // Transformed input (Angular 16+)\n  @Input({ transform: (value: string) => value.toUpperCase() })\n  description: string = '';\n}",this.outputCode="@Component({\n  selector: 'app-counter',\n  template: `\n    <div>\n      <h2>Count: {{ count }}</h2>\n      <button (click)=\"increment()\">Increment</button>\n      <button (click)=\"reset()\">Reset</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  // Basic output\n  @Output() countChanged = new EventEmitter<number>();\n\n  // Output with alias\n  @Output('resetEvent') resetTriggered = new EventEmitter<void>();\n\n  increment() {\n    this.count++;\n    this.countChanged.emit(this.count);\n  }\n\n  reset() {\n    this.count = 0;\n    this.resetTriggered.emit();\n    this.countChanged.emit(this.count);\n  }\n}",this.viewChildCode="@Component({\n  selector: 'app-tabbed-panel',\n  template: `\n    <div>\n      <div #tabHeader class=\"tab-header\">\n        <button *ngFor=\"let tab of tabs\" (click)=\"selectTab(tab)\">\n          {{ tab.title }}\n        </button>\n      </div>\n      <div class=\"tab-content\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  `\n})\nexport class TabbedPanelComponent implements AfterViewInit {\n  // Reference to a single element\n  @ViewChild('tabHeader') tabHeader!: ElementRef;\n\n  // Reference to a component\n  @ViewChild(TabComponent) activeTab?: TabComponent;\n\n  // Reference to a directive with specific read option\n  @ViewChild('tabHeader', { read: ViewContainerRef })\n  headerContainer!: ViewContainerRef;\n\n  // Multiple elements with ViewChildren\n  @ViewChildren(TabComponent) allTabs!: QueryList<TabComponent>;\n\n  // Static option for immediate availability\n  @ViewChild('staticContent', { static: true })\n  staticContent!: ElementRef;\n\n  ngAfterViewInit() {\n    console.log('Tab header element:', this.tabHeader.nativeElement);\n    this.allTabs.forEach(tab => console.log('Tab:', tab.title));\n  }\n}",this.hostBindingCode="@Directive({\n  selector: '[appHighlight]',\n  standalone: true\n})\nexport class HighlightDirective {\n  // Color for the highlight, defaults to yellow\n  @Input() highlightColor = 'yellow';\n\n  // Bind to the style.backgroundColor property of the host element\n  @HostBinding('style.backgroundColor') backgroundColor: string = '';\n\n  // Bind to the class.active property of the host element\n  @HostBinding('class.active') isActive = false;\n\n  // Bind to the attr.aria-label property\n  @HostBinding('attr.aria-label') ariaLabel = 'Highlighted element';\n\n  // Listen for mouseenter event and apply highlighting\n  @HostListener('mouseenter')\n  onMouseEnter() {\n    this.backgroundColor = this.highlightColor;\n    this.isActive = true;\n  }\n\n  // Listen for mouseleave event and remove highlighting\n  @HostListener('mouseleave')\n  onMouseLeave() {\n    this.backgroundColor = '';\n    this.isActive = false;\n  }\n}",this.signalInputCode="// Modern signal-based inputs (Angular 19)\n@Component({\n  selector: 'app-product-card',\n  template: `\n    <div class=\"product\">\n      <h2>{{ name() }}</h2>\n      <div>Price: {{ price() | currency }}</div>\n      <div *ngIf=\"isOnSale()\">ON SALE!</div>\n      <button [disabled]=\"!inStock()\" (click)=\"addToCart()\">\n        {{ inStock() ? 'Add to Cart' : 'Out of Stock' }}\n      </button>\n    </div>\n  `\n})\nexport class ProductCardComponent {\n  // Basic input signal\n  name = input<string>('');\n\n  // Input signal with transform function\n  price = input<number>(0, {\n    transform: (value: number) => Math.max(0, value)\n  });\n\n  // Required input signal\n  id = input.required<string>();\n\n  // Input signal with default value\n  inStock = input<boolean>(true);\n\n  // Model input (two-way bindable)\n  quantity = model<number>(1);\n\n  // Computed value based on input signals\n  isOnSale = computed(() => {\n    return this.price() < 50;\n  });\n\n  // Output signal\n  addedToCart = output<{id: string, quantity: number}>();\n\n  addToCart() {\n    if (this.inStock()) {\n      this.addedToCart.emit({\n        id: this.id(),\n        quantity: this.quantity()\n      });\n    }\n  }\n}"}ngOnInit(){}}s.\u0275fac=function(){let i;return function(t){return(i||(i=e.n5z(s)))(t||s)}}(),s.\u0275cmp=e.Xpm({type:s,selectors:[["app-class-field-decorator"]],viewQuery:function(r,t){if(1&r&&(e.Gf(g,5),e.Gf(Z,5),e.Gf(_,5),e.Gf(m,5),e.Gf(h,5)),2&r){let n;e.iGM(n=e.CRH())&&(t.inputCodeEl=n.first),e.iGM(n=e.CRH())&&(t.outputCodeEl=n.first),e.iGM(n=e.CRH())&&(t.viewChildCodeEl=n.first),e.iGM(n=e.CRH())&&(t.hostBindingCodeEl=n.first),e.iGM(n=e.CRH())&&(t.signalInputCodeEl=n.first)}},standalone:!0,features:[e.qOj,e.jDz],decls:24,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[4,"ngIf"],[1,"list-disc","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["inputCodeEl",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["outputCodeEl",""],["viewChildCodeEl",""],["hostBindingCodeEl",""],["signalInputCodeEl",""],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","pl-4","text-sm"],[1,"text-sky-400"],[1,"text-sm"],[1,"font-semibold","text-sky-400","mb-2"],[1,"list-disc","pl-4","mb-6"],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md","mb-4"],[1,"border-b","border-gray-700","bg-gray-900"],[1,"border-b","border-gray-700","bg-gray-950"],["href","https://angular.dev/guide/components/inputs",1,"text-sky-400","hover:underline"],["href","https://angular.dev/guide/components/outputs",1,"text-sky-400","hover:underline"],["href","https://angular.dev/guide/components/view-encapsulation",1,"text-sky-400","hover:underline"],["href","https://angular.dev/guide/signals",1,"text-sky-400","hover:underline"],["href","https://www.typescriptlang.org/docs/handbook/decorators.html",1,"text-sky-400","hover:underline"]],template:function(r,t){1&r&&(e.TgZ(0,"section",0)(1,"p",1),e._uU(2," Class Field Decorators in Angular "),e.qZA(),e.TgZ(3,"div",2)(4,"p")(5,"span",3),e._uU(6,"Class Field Decorators"),e.qZA(),e._uU(7," in Angular 19 are TypeScript decorators that add metadata to class properties and methods. These decorators enable Angular to understand how properties interact with components, templates, and the DOM, providing essential functionality like property binding, event handling, and DOM access. "),e.qZA(),e._UZ(8,"br"),e.TgZ(9,"div",4)(10,"div",5)(11,"button",6),e.NdJ("click",function(){return t.selectedTab=1}),e._uU(12," Notes "),e.qZA(),e.TgZ(13,"button",6),e.NdJ("click",function(){return t.selectedTab=2}),e._uU(14," Best Practices "),e.qZA(),e.TgZ(15,"button",6),e.NdJ("click",function(){return t.selectedTab=3}),e._uU(16," Pros and Cons "),e.qZA(),e.TgZ(17,"button",6),e.NdJ("click",function(){return t.selectedTab=4}),e._uU(18," Related Topics "),e.qZA()(),e.TgZ(19,"div",7),e.YNc(20,A,192,15,"div",8),e.YNc(21,T,70,2,"div",8),e.YNc(22,U,101,6,"div",8),e.YNc(23,f,71,6,"div",8),e.qZA()()()()),2&r&&(e.xp6(11),e.ekj("text-rose-300",1===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",2===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",3===t.selectedTab),e.xp6(2),e.ekj("text-rose-300",4===t.selectedTab),e.xp6(3),e.Q6J("ngIf",1===t.selectedTab),e.xp6(1),e.Q6J("ngIf",2===t.selectedTab),e.xp6(1),e.Q6J("ngIf",3===t.selectedTab),e.xp6(1),e.Q6J("ngIf",4===t.selectedTab))},dependencies:[d.ez,d.O5,c._l,c.y$],changeDetection:0})}}]);