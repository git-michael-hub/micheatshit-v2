"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[432],{9432:(J,p,a)=>{a.r(p),a.d(p,{PartialHydrationModule:()=>d});var s=a(6895),g=a(7178),u=a(827),m=a(8512),t=a(8256),Z=a(529);const y=["code1"],h=["code2"],_=["code3"],f=["code4"],A=["notesRef"],U=["bestRef"],v=["prosConsRef"],T=["topicsRef"];function q(n,o){1&n&&t.GkF(0)}function b(n,o){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,q,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(28);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function C(n,o){1&n&&t.GkF(0)}function w(n,o){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,C,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(30);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function H(n,o){1&n&&t.GkF(0)}function x(n,o){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,H,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(32);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}function P(n,o){1&n&&t.GkF(0)}function S(n,o){if(1&n&&(t.TgZ(0,"div"),t.YNc(1,P,1,0,"ng-container",15),t.qZA()),2&n){t.oxw();const e=t.MAs(26);t.xp6(1),t.Q6J("ngTemplateOutlet",e)}}const c=function(){return["typescript"]},I=function(){return["html"]};function M(n,o){if(1&n){const e=t.EpF();t.TgZ(0,"p"),t._uU(1,"What is Partial Hydration?"),t.qZA(),t.TgZ(2,"ul",16)(3,"li")(4,"strong"),t._uU(5,"Selective Rehydration"),t.qZA(),t._uU(6,": Enables an app to selectively rehydrate only the interactive parts of server-rendered HTML, leaving static content as-is. "),t.qZA(),t.TgZ(7,"li")(8,"strong"),t._uU(9,"Performance Optimization"),t.qZA(),t._uU(10,": Reduces JavaScript bundle size and execution overhead by not rehydrating static content. "),t.qZA(),t.TgZ(11,"li")(12,"strong"),t._uU(13,"Island Architecture"),t.qZA(),t._uU(14,': Enables "islands of interactivity" within static content, focused on specific interactive components. '),t.qZA(),t.TgZ(15,"li")(16,"strong"),t._uU(17,"Progressive Enhancement"),t.qZA(),t._uU(18,": Improves initial load performance while gradually adding interactivity where needed. "),t.qZA()(),t._UZ(19,"br")(20,"br"),t.TgZ(21,"p"),t._uU(22,"Basic Hydration Setup"),t.qZA(),t.TgZ(23,"button",17),t.NdJ("click",function(){t.CHM(e);const r=t.MAs(26);return t.KtG(r.hidden=!r.hidden)}),t._uU(24,"code"),t.qZA(),t.TgZ(25,"span",18,19)(27,"div",20)(28,"span"),t._uU(29,"typescript"),t.qZA(),t._UZ(30,"span",21),t.qZA(),t.TgZ(31,"pre"),t._uU(32,"      "),t.TgZ(33,"code",22),t._uU(34,"\n      "),t.qZA(),t._uU(35,"\n    "),t.qZA()(),t._UZ(36,"br")(37,"br"),t.TgZ(38,"p"),t._uU(39,"Selective Hydration Example"),t.qZA(),t.TgZ(40,"button",17),t.NdJ("click",function(){t.CHM(e);const r=t.MAs(43);return t.KtG(r.hidden=!r.hidden)}),t._uU(41,"code"),t.qZA(),t.TgZ(42,"span",18,23)(44,"div",20)(45,"span"),t._uU(46,"html"),t.qZA(),t._UZ(47,"span",21),t.qZA(),t.TgZ(48,"pre"),t._uU(49,"      "),t.TgZ(50,"code",22),t._uU(51,"\n      "),t.qZA(),t._uU(52,"\n    "),t.qZA()(),t._UZ(53,"br")(54,"br"),t.TgZ(55,"p"),t._uU(56,"Progressive Hydration Strategy"),t.qZA(),t.TgZ(57,"button",17),t.NdJ("click",function(){t.CHM(e);const r=t.MAs(60);return t.KtG(r.hidden=!r.hidden)}),t._uU(58,"code"),t.qZA(),t.TgZ(59,"span",18,24)(61,"div",20)(62,"span"),t._uU(63,"typescript"),t.qZA(),t._UZ(64,"span",21),t.qZA(),t.TgZ(65,"pre"),t._uU(66,"      "),t.TgZ(67,"code",22),t._uU(68,"\n      "),t.qZA(),t._uU(69,"\n    "),t.qZA()(),t._UZ(70,"br")(71,"br"),t.TgZ(72,"p"),t._uU(73,"New in Angular 19: Enhanced Partial Hydration"),t.qZA(),t.TgZ(74,"button",17),t.NdJ("click",function(){t.CHM(e);const r=t.MAs(77);return t.KtG(r.hidden=!r.hidden)}),t._uU(75,"code"),t.qZA(),t.TgZ(76,"span",18,25)(78,"div",20)(79,"span"),t._uU(80,"typescript"),t.qZA(),t._UZ(81,"span",21),t.qZA(),t.TgZ(82,"pre"),t._uU(83,"      "),t.TgZ(84,"code",22),t._uU(85,"\n      "),t.qZA(),t._uU(86,"\n    "),t.qZA()(),t._UZ(87,"br")(88,"br"),t.TgZ(89,"p"),t._uU(90,"Key Enhancements in Angular 19"),t.qZA(),t.TgZ(91,"ol",26)(92,"li")(93,"strong"),t._uU(94,"Component-Level Hydration Control"),t.qZA(),t._uU(95,": "),t.TgZ(96,"ul",27)(97,"li"),t._uU(98,"Ability to set hydration preferences at the component level through a new API."),t.qZA(),t.TgZ(99,"li"),t._uU(100,"Options for on, off, conditional, or deferred hydration based on component needs."),t.qZA()()(),t.TgZ(101,"li")(102,"strong"),t._uU(103,"Integration with Signal-Based Components"),t.qZA(),t._uU(104,": "),t.TgZ(105,"ul",27)(106,"li"),t._uU(107,"Fine-grained reactivity control allowing specific parts of a component to be reactive while others remain static."),t.qZA(),t.TgZ(108,"li"),t._uU(109,"Optimized hydration for signals-based reactivity with minimal JavaScript overhead."),t.qZA()()(),t.TgZ(110,"li")(111,"strong"),t._uU(112,"Hydration Trigger API"),t.qZA(),t._uU(113,": "),t.TgZ(114,"ul",27)(115,"li"),t._uU(116,"New triggers like viewport visibility, user interaction, and idle browser time."),t.qZA(),t.TgZ(117,"li"),t._uU(118,"Programmatic control to hydrate components when needed, rather than automatically."),t.qZA()()(),t.TgZ(119,"li")(120,"strong"),t._uU(121,"Island Architecture Support"),t.qZA(),t._uU(122,": "),t.TgZ(123,"ul",27)(124,"li"),t._uU(125,"First-class support for island architecture pattern with isolated islands of interactivity."),t.qZA(),t.TgZ(126,"li"),t._uU(127,"Improved tree-shaking for non-hydrated components to further reduce bundle size."),t.qZA()()(),t.TgZ(128,"li")(129,"strong"),t._uU(130,"Integration with Deferrable Views"),t.qZA(),t._uU(131,": "),t.TgZ(132,"ul",27)(133,"li"),t._uU(134,"Combination of partial hydration with deferrable views for optimal loading strategies."),t.qZA(),t.TgZ(135,"li"),t._uU(136,"Ability to selectively hydrate different parts of a deferred block when loaded."),t.qZA()()()(),t._UZ(137,"br")(138,"br"),t.TgZ(139,"p"),t._uU(140,"Performance Impact of Partial Hydration"),t.qZA(),t.TgZ(141,"table",28)(142,"thead")(143,"tr",29)(144,"th",30),t._uU(145,"Metric"),t.qZA(),t.TgZ(146,"th",30),t._uU(147,"Improvement"),t.qZA(),t.TgZ(148,"th",30),t._uU(149,"Typical Impact"),t.qZA()()(),t.TgZ(150,"tbody")(151,"tr",31)(152,"td",32),t._uU(153,"Time to Interactive (TTI)"),t.qZA(),t.TgZ(154,"td",32),t._uU(155,"Prioritizes critical UI hydration"),t.qZA(),t.TgZ(156,"td",32),t._uU(157,"30-50% faster TTI"),t.qZA()(),t.TgZ(158,"tr",33)(159,"td",32),t._uU(160,"JavaScript Bundle Size"),t.qZA(),t.TgZ(161,"td",32),t._uU(162,"Reduced framework code per component"),t.qZA(),t.TgZ(163,"td",32),t._uU(164,"20-40% smaller bundles"),t.qZA()(),t.TgZ(165,"tr",31)(166,"td",32),t._uU(167,"First Input Delay (FID)"),t.qZA(),t.TgZ(168,"td",32),t._uU(169,"Less JavaScript execution on load"),t.qZA(),t.TgZ(170,"td",32),t._uU(171,"Improved by 25-45%"),t.qZA()(),t.TgZ(172,"tr",34)(173,"td",32),t._uU(174,"Memory Usage"),t.qZA(),t.TgZ(175,"td",32),t._uU(176,"Fewer active Angular components"),t.qZA(),t.TgZ(177,"td",32),t._uU(178,"Reduced by up to 35%"),t.qZA()()()()}if(2&n){const e=t.oxw();t.xp6(33),t.Q6J("highlight",e.basicHydrationCode)("languages",t.DdM(8,c)),t.xp6(17),t.Q6J("highlight",e.partialHydrationCode)("languages",t.DdM(9,I)),t.xp6(17),t.Q6J("highlight",e.hydrationStrategyCode)("languages",t.DdM(10,c)),t.xp6(17),t.Q6J("highlight",e.v19EnhancementsCode)("languages",t.DdM(11,c))}}function k(n,o){1&n&&(t.TgZ(0,"ol",35)(1,"li")(2,"strong",36),t._uU(3,"Analyze Your Components for Hydration Needs"),t.qZA(),t.TgZ(4,"ul",27)(5,"li")(6,"strong"),t._uU(7,"Classify Components"),t.qZA(),t._uU(8,": Categorize components as static (never need hydration), interactive (always need hydration), or conditionally interactive. "),t.qZA(),t.TgZ(9,"li")(10,"strong"),t._uU(11,"Audit Interactivity Requirements"),t.qZA(),t._uU(12,": For each component, determine if it needs immediate interactivity or can be hydrated later. "),t.qZA(),t.TgZ(13,"li")(14,"strong"),t._uU(15,"Consider User Flow"),t.qZA(),t._uU(16,": Prioritize hydration based on the typical user journey through your application. "),t.qZA()()(),t.TgZ(17,"li")(18,"strong",36),t._uU(19,"Design with Island Architecture in Mind"),t.qZA(),t.TgZ(20,"ul",27)(21,"li")(22,"strong"),t._uU(23,"Isolate Interactive Components"),t.qZA(),t._uU(24,": Design your UI with clear boundaries between interactive and static content. "),t.qZA(),t.TgZ(25,"li")(26,"strong"),t._uU(27,"Minimize Component Dependencies"),t.qZA(),t._uU(28,": Reduce dependencies between hydrated and non-hydrated components to avoid forced hydration. "),t.qZA(),t.TgZ(29,"li")(30,"strong"),t._uU(31,"State Management Boundaries"),t.qZA(),t._uU(32,": Design state management to work with partially hydrated applications. "),t.qZA()()(),t.TgZ(33,"li")(34,"strong",36),t._uU(35,"Implement Progressive Hydration Strategies"),t.qZA(),t.TgZ(36,"ul",27)(37,"li")(38,"strong"),t._uU(39,"Critical Path First"),t.qZA(),t._uU(40,": Hydrate components on the critical user path first, deferring others. "),t.qZA(),t.TgZ(41,"li")(42,"strong"),t._uU(43,"Visibility-Based Hydration"),t.qZA(),t._uU(44,": Use viewport-based hydration triggers for below-the-fold content. "),t.qZA(),t.TgZ(45,"li")(46,"strong"),t._uU(47,"Interaction-Based Hydration"),t.qZA(),t._uU(48,": Hydrate some components only when users interact with related UI elements. "),t.qZA()()(),t.TgZ(49,"li")(50,"strong",36),t._uU(51,"Combine with Other Performance Techniques"),t.qZA(),t.TgZ(52,"ul",27)(53,"li")(54,"strong"),t._uU(55,"Use with Deferrable Views"),t.qZA(),t._uU(56,": Combine partial hydration with deferrable views for optimal loading performance. "),t.qZA(),t.TgZ(57,"li")(58,"strong"),t._uU(59,"Signal-Based Reactivity"),t.qZA(),t._uU(60,": Use signal-based components for fine-grained reactivity control in hydrated components. "),t.qZA(),t.TgZ(61,"li")(62,"strong"),t._uU(63,"Lazy Loading"),t.qZA(),t._uU(64,": Implement route-level lazy loading alongside partial hydration for best results. "),t.qZA()()(),t.TgZ(65,"li")(66,"strong",36),t._uU(67,"Test and Measure Performance Impact"),t.qZA(),t.TgZ(68,"ul",27)(69,"li")(70,"strong"),t._uU(71,"Use Angular DevTools"),t.qZA(),t._uU(72,": Leverage Angular DevTools' hydration visualization to see which components are hydrated. "),t.qZA(),t.TgZ(73,"li")(74,"strong"),t._uU(75,"Monitor Core Web Vitals"),t.qZA(),t._uU(76,": Track improvements in FID, LCP, and CLS metrics when implementing partial hydration. "),t.qZA(),t.TgZ(77,"li")(78,"strong"),t._uU(79,"Test on Real Devices"),t.qZA(),t._uU(80,": Verify performance improvements on lower-powered devices where the impact will be most noticeable. "),t.qZA()()()())}function D(n,o){1&n&&(t.TgZ(0,"strong",36),t._uU(1," Pros: "),t.qZA(),t._UZ(2,"br"),t.TgZ(3,"ol",37)(4,"li")(5,"strong"),t._uU(6,"Performance Improvements"),t.qZA(),t.TgZ(7,"ul",27)(8,"li")(9,"span",3),t._uU(10,"Faster Initial Interactivity"),t.qZA(),t._uU(11,": By hydrating only critical components first, Time to Interactive (TTI) is significantly reduced. "),t.qZA(),t.TgZ(12,"li")(13,"span",3),t._uU(14,"Reduced JavaScript Overhead"),t.qZA(),t._uU(15,": Only the necessary JavaScript for interactive components is loaded and executed. "),t.qZA(),t.TgZ(16,"li")(17,"span",3),t._uU(18,"Improved Core Web Vitals"),t.qZA(),t._uU(19,": First Input Delay (FID) and Largest Contentful Paint (LCP) metrics typically improve. "),t.qZA()()(),t.TgZ(20,"li")(21,"strong"),t._uU(22,"Enhanced User Experience"),t.qZA(),t.TgZ(23,"ul",27)(24,"li")(25,"span",3),t._uU(26,"Progressive Enhancement"),t.qZA(),t._uU(27,": Content is visible immediately, with interactivity progressively added as needed. "),t.qZA(),t.TgZ(28,"li")(29,"span",3),t._uU(30,"Prioritized Interactivity"),t.qZA(),t._uU(31,": Critical interactive elements become responsive faster than non-essential ones. "),t.qZA(),t.TgZ(32,"li")(33,"span",3),t._uU(34,"Better Mobile Experience"),t.qZA(),t._uU(35,": Particularly beneficial for mobile users with limited processing power and bandwidth. "),t.qZA()()(),t.TgZ(36,"li")(37,"strong"),t._uU(38,"Resource Efficiency"),t.qZA(),t.TgZ(39,"ul",27)(40,"li")(41,"span",3),t._uU(42,"Reduced Memory Usage"),t.qZA(),t._uU(43,": Fewer active Angular components mean less memory consumption by the application. "),t.qZA(),t.TgZ(44,"li")(45,"span",3),t._uU(46,"Lower CPU Utilization"),t.qZA(),t._uU(47,": Less change detection and reactive processing for non-hydrated parts of the app. "),t.qZA(),t.TgZ(48,"li")(49,"span",3),t._uU(50,"Battery Efficiency"),t.qZA(),t._uU(51,": Less JavaScript execution translates to better battery life on mobile devices. "),t.qZA()()(),t.TgZ(52,"li")(53,"strong"),t._uU(54,"Angular 19 Specific Benefits"),t.qZA(),t.TgZ(55,"ul",27)(56,"li")(57,"span",3),t._uU(58,"Fine-grained Control"),t.qZA(),t._uU(59,": Component-level hydration options provide unprecedented control over the hydration process. "),t.qZA(),t.TgZ(60,"li")(61,"span",3),t._uU(62,"Integration with Signals"),t.qZA(),t._uU(63,": Signal-based reactivity works perfectly with partial hydration for efficient updates. "),t.qZA(),t.TgZ(64,"li")(65,"span",3),t._uU(66,"Developer Experience"),t.qZA(),t._uU(67,": Built-in tooling and APIs make implementing partial hydration more straightforward. "),t.qZA()()()(),t._UZ(68,"br")(69,"br"),t.TgZ(70,"strong",36),t._uU(71," Cons: "),t.qZA(),t._UZ(72,"br"),t.TgZ(73,"ol",37)(74,"li")(75,"strong"),t._uU(76,"Increased Complexity"),t.qZA(),t.TgZ(77,"ul",27)(78,"li")(79,"span",3),t._uU(80,"Architecture Planning"),t.qZA(),t._uU(81,": Requires careful planning of component boundaries and interaction patterns. "),t.qZA(),t.TgZ(82,"li")(83,"span",3),t._uU(84,"Hydration Strategy"),t.qZA(),t._uU(85,": Determining which components to hydrate and when adds complexity to application design. "),t.qZA(),t.TgZ(86,"li")(87,"span",3),t._uU(88,"Debugging Challenges"),t.qZA(),t._uU(89,": Issues with partially hydrated applications can be more difficult to debug. "),t.qZA()()(),t.TgZ(90,"li")(91,"strong"),t._uU(92,"Development Considerations"),t.qZA(),t.TgZ(93,"ul",27)(94,"li")(95,"span",3),t._uU(96,"Component Design Constraints"),t.qZA(),t._uU(97,": Components must be designed with hydration boundaries in mind, potentially limiting reuse. "),t.qZA(),t.TgZ(98,"li")(99,"span",3),t._uU(100,"State Management Complexity"),t.qZA(),t._uU(101,": Managing state between hydrated and non-hydrated components requires careful planning. "),t.qZA(),t.TgZ(102,"li")(103,"span",3),t._uU(104,"Integration Challenges"),t.qZA(),t._uU(105,": Some third-party libraries may not work well with partial hydration strategies. "),t.qZA()()(),t.TgZ(106,"li")(107,"strong"),t._uU(108,"Potential Pitfalls"),t.qZA(),t.TgZ(109,"ul",27)(110,"li")(111,"span",3),t._uU(112,"Unexpected Hydration"),t.qZA(),t._uU(113,": Component dependencies can trigger unexpected hydration of supposedly static content. "),t.qZA(),t.TgZ(114,"li")(115,"span",3),t._uU(116,"Delayed Interactivity"),t.qZA(),t._uU(117,": If hydration triggers are misconfigured, users might experience delays in interactive elements. "),t.qZA(),t.TgZ(118,"li")(119,"span",3),t._uU(120,"Hydration Mismatches"),t.qZA(),t._uU(121,": Server-rendered content that doesn't match client expectations can cause hydration errors. "),t.qZA()()(),t.TgZ(122,"li")(123,"strong"),t._uU(124,"Testing Challenges"),t.qZA(),t.TgZ(125,"ul",27)(126,"li")(127,"span",3),t._uU(128,"Complex Test Scenarios"),t.qZA(),t._uU(129,": Testing hydration scenarios requires more sophisticated testing approaches. "),t.qZA(),t.TgZ(130,"li")(131,"span",3),t._uU(132,"Environment Dependencies"),t.qZA(),t._uU(133,": Behavior may vary between development and production environments. "),t.qZA(),t.TgZ(134,"li")(135,"span",3),t._uU(136,"User Experience Variability"),t.qZA(),t._uU(137,": Different users may experience different hydration timing based on their devices and behavior. "),t.qZA()()()())}function R(n,o){1&n&&(t.TgZ(0,"ol",37)(1,"li")(2,"strong"),t._uU(3,"Server-Side Rendering (SSR)"),t.qZA(),t.TgZ(4,"ul",27)(5,"li")(6,"strong",36),t._uU(7,"Description"),t.qZA(),t._uU(8,": Rendering Angular applications on the server before sending HTML to the client. "),t.qZA(),t.TgZ(9,"li")(10,"strong",36),t._uU(11,"Relation to Partial Hydration"),t.qZA(),t._uU(12,": SSR is the foundation for partial hydration, which builds upon server-rendered content by selectively making it interactive. "),t.qZA()()(),t.TgZ(13,"li")(14,"strong"),t._uU(15,"Hydration"),t.qZA(),t.TgZ(16,"ul",27)(17,"li")(18,"strong",36),t._uU(19,"Description"),t.qZA(),t._uU(20,": The process of making server-rendered HTML interactive by attaching event listeners and Angular components. "),t.qZA(),t.TgZ(21,"li")(22,"strong",36),t._uU(23,"Relation to Partial Hydration"),t.qZA(),t._uU(24,": Partial hydration is a more selective approach to hydration, where only specific components are hydrated. "),t.qZA()()(),t.TgZ(25,"li")(26,"strong"),t._uU(27,"Deferrable Views"),t.qZA(),t.TgZ(28,"ul",27)(29,"li")(30,"strong",36),t._uU(31,"Description"),t.qZA(),t._uU(32,": Angular's "),t.TgZ(33,"code"),t._uU(34,"@defer"),t.qZA(),t._uU(35," blocks that enable lazy loading of template fragments. "),t.qZA(),t.TgZ(36,"li")(37,"strong",36),t._uU(38,"Relation to Partial Hydration"),t.qZA(),t._uU(39,": Can be combined with partial hydration to create highly optimized loading patterns where content is both deferred and selectively hydrated. "),t.qZA()()(),t.TgZ(40,"li")(41,"strong"),t._uU(42,"Signal-Based Components"),t.qZA(),t.TgZ(43,"ul",27)(44,"li")(45,"strong",36),t._uU(46,"Description"),t.qZA(),t._uU(47,": Components built using Angular's signals system for fine-grained reactivity. "),t.qZA(),t.TgZ(48,"li")(49,"strong",36),t._uU(50,"Relation to Partial Hydration"),t.qZA(),t._uU(51,": Signal-based components integrate well with partial hydration, enabling efficient reactive updates only where needed. "),t.qZA()()(),t.TgZ(52,"li")(53,"strong"),t._uU(54,"Island Architecture"),t.qZA(),t.TgZ(55,"ul",27)(56,"li")(57,"strong",36),t._uU(58,"Description"),t.qZA(),t._uU(59,": Web development approach where interactive islands exist within a sea of static content. "),t.qZA(),t.TgZ(60,"li")(61,"strong",36),t._uU(62,"Relation to Partial Hydration"),t.qZA(),t._uU(63,": Partial hydration is the technical implementation that enables island architecture in Angular applications. "),t.qZA()()(),t.TgZ(64,"li")(65,"strong"),t._uU(66,"Core Web Vitals"),t.qZA(),t.TgZ(67,"ul",27)(68,"li")(69,"strong",36),t._uU(70,"Description"),t.qZA(),t._uU(71,": Google's metrics for measuring user experience quality, including LCP, FID, and CLS. "),t.qZA(),t.TgZ(72,"li")(73,"strong",36),t._uU(74,"Relation to Partial Hydration"),t.qZA(),t._uU(75,": Partial hydration improves Core Web Vitals metrics by reducing JavaScript execution and prioritizing critical interactivity. "),t.qZA()()(),t.TgZ(76,"li")(77,"strong"),t._uU(78,"Progressive Enhancement"),t.qZA(),t.TgZ(79,"ul",27)(80,"li")(81,"strong",36),t._uU(82,"Description"),t.qZA(),t._uU(83,": Strategy of starting with essential content and functionality, then enhancing the experience for capable browsers/devices. "),t.qZA(),t.TgZ(84,"li")(85,"strong",36),t._uU(86,"Relation to Partial Hydration"),t.qZA(),t._uU(87,": Partial hydration is a modern implementation of progressive enhancement, starting with static content and progressively adding interactivity. "),t.qZA()()()())}class l extends m.Y{constructor(o){super(),this.http=o,this.selectedTab=1,this.basicHydrationCode="// app.config.ts\nimport { ApplicationConfig } from '@angular/core';\nimport { provideClientHydration } from '@angular/platform-browser';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideClientHydration() // Enable hydration for the entire application\n  ]\n};",this.partialHydrationCode='\x3c!-- Using partial hydration with selective hydration --\x3e\n<div>\n  \x3c!-- This component will be hydrated --\x3e\n  <app-interactive-counter hydration="on"></app-interactive-counter>\n\n  \x3c!-- This component will remain static, never hydrated --\x3e\n  <app-static-content hydration="off"></app-static-content>\n\n  \x3c!-- This component will be hydrated only after user interaction --\x3e\n  <app-lazy-dashboard hydration="user-interactive"></app-lazy-dashboard>\n</div>',this.hydrationStrategyCode="// Progressive hydration strategy in Angular 19\nimport { NgModule } from '@angular/core';\nimport { BrowserModule, provideClientHydration } from '@angular/platform-browser';\nimport { provideHydrationStrategy, HydrationStrategy } from '@angular/core';\n\n// Custom progressive hydration strategy\nclass MyProgressiveStrategy implements HydrationStrategy {\n  shouldHydrateComponent(element: Element): boolean {\n    // Only hydrate components with specific attributes or in viewport\n    return element.hasAttribute('priority-hydrate') || this.isInViewport(element);\n  }\n\n  shouldHydrateChildren(element: Element): boolean {\n    // Don't automatically hydrate children of lazy sections\n    return !element.hasAttribute('lazy-section');\n  }\n\n  private isInViewport(element: Element): boolean {\n    const rect = element.getBoundingClientRect();\n    return (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= window.innerHeight &&\n      rect.right <= window.innerWidth\n    );\n  }\n}\n\n// Provide custom hydration strategy\n@NgModule({\n  imports: [BrowserModule],\n  providers: [\n    provideClientHydration(),\n    provideHydrationStrategy(MyProgressiveStrategy)\n  ]\n})\nexport class AppModule { }",this.v19EnhancementsCode='// Angular 19 Enhanced Partial Hydration Features\n\n// 1. Component-level hydration control\n@Component({\n  selector: \'app-dashboard\',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div>\n      <header>Dashboard</header>\n\n      \x3c!-- Island architecture with selective hydration --\x3e\n      <div class="widget" hydration="on">\n        <app-interactive-chart [data]="chartData"></app-interactive-chart>\n      </div>\n\n      <div class="content" hydration="off">\n        <app-static-article></app-static-article>\n      </div>\n\n      <div class="comments" hydration="when-visible">\n        <app-comments-section></app-comments-section>\n      </div>\n    </div>\n  `,\n  hydration: {\n    strategy: \'selective\',\n    defaultMode: \'off\'\n  }\n})\nexport class DashboardComponent { }\n\n// 2. Integration with signals for fine-grained reactivity\n@Component({\n  selector: \'app-analytics\',\n  standalone: true,\n  template: `\n    <div>\n      \x3c!-- Only the counter updates, rest stays static --\x3e\n      <h2>Visitors: {{ visitorCount() }}</h2>\n      <div hydration="off">Static analytics visualization</div>\n    </div>\n  `,\n  hydration: \'minimal\'\n})\nexport class AnalyticsComponent {\n  visitorCount = signal(0);\n  // ...\n}',this.code_1="// Marking a component for partial hydration\nimport { Component } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\n\n@Component({\n  selector: 'app-static-content',\n  template: `\n    <div>\n      <h2>This component will not be hydrated</h2>\n      <p>This content will remain static after server-side rendering</p>\n    </div>\n  `,\n  standalone: true,\n  hydration: {\n    componentHydration: false\n  }\n})\nexport class StaticContentComponent {}\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <app-static-content></app-static-content>\n    <app-interactive-component></app-interactive-component>\n  `,\n  standalone: true,\n  imports: [StaticContentComponent]\n})\nexport class AppComponent {}\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration()]\n});",this.code_2="// Using componentHydration option in hydration configuration\nimport { Component } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideClientHydration } from '@angular/platform-browser';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [HeaderComponent, MainContentComponent, FooterComponent],\n  template: `\n    <app-header></app-header>\n    <app-main-content></app-main-content>\n    <app-footer></app-footer>\n  `\n})\nexport class AppComponent {}\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideClientHydration({\n      componentHydration: (def) => {\n        // Only hydrate interactive components\n        if (def === HeaderComponent || def === FooterComponent) {\n          // Static components - no hydration needed\n          return false;\n        }\n        // Other components will be hydrated\n        return true;\n      }\n    })\n  ]\n});",this.code_3="// Angular 19 hydration with Islands architecture pattern\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideClientHydration } from '@angular/platform-browser';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideClientHydration({\n      // Hydration strategy for components\n      componentHydration: (componentDef) => {\n        // Check component metadata for hydration preference\n        const hydrationMetadata = componentDef.type['__hydration'];\n\n        if (hydrationMetadata?.skip) {\n          // Skip hydration for static components\n          return false;\n        }\n\n        if (hydrationMetadata?.priority === 'low') {\n          // Queue low-priority components for delayed hydration\n          queueMicrotask(() => {\n            // Logic to hydrate later\n          });\n          return false;\n        }\n\n        // Default: hydrate normally\n        return true;\n      },\n\n      // Skip attribute hydration for specific attributes\n      attributeHydration: (element, attributeName) => {\n        // Skip hydration for static attributes\n        return !attributeName.startsWith('data-static');\n      }\n    })\n  ]\n});",this.code_4="// Selective Islands hydration component decorator\nimport { Component, Input } from '@angular/core';\n\n// Custom decorator factory for Islands architecture\nexport function Island(options: {\n  hydrate: boolean | 'lazy' | 'idle' | 'visible',\n  prerender?: boolean\n} = { hydrate: true, prerender: true }) {\n\n  return function(target: any) {\n    // Store hydration metadata on the component class\n    target['__hydration'] = {\n      hydrate: options.hydrate,\n      prerender: options.prerender\n    };\n\n    // Original component remains unchanged\n    return target;\n  };\n}\n\n// Usage example\n@Island({ hydrate: 'visible' })\n@Component({\n  selector: 'app-comments-section',\n  template: `\n    <div class=\"comments-section\">\n      <h3>Comments</h3>\n      <ul>\n        <li *ngFor=\"let comment of comments\">{{ comment.text }}</li>\n      </ul>\n      <button (click)=\"addComment()\">Add Comment</button>\n    </div>\n  `\n})\nexport class CommentsSectionComponent {\n  @Input() comments: any[] = [];\n\n  addComment() {\n    // Interactive functionality\n  }\n}"}ngOnInit(){}}l.\u0275fac=function(o){return new(o||l)(t.Y36(Z.eN))},l.\u0275cmp=t.Xpm({type:l,selectors:[["app-partial-hydration"]],viewQuery:function(o,e){if(1&o&&(t.Gf(y,5),t.Gf(h,5),t.Gf(_,5),t.Gf(f,5),t.Gf(A,5),t.Gf(U,5),t.Gf(v,5),t.Gf(T,5)),2&o){let i;t.iGM(i=t.CRH())&&(e.code1=i.first),t.iGM(i=t.CRH())&&(e.code2=i.first),t.iGM(i=t.CRH())&&(e.code3=i.first),t.iGM(i=t.CRH())&&(e.code4=i.first),t.iGM(i=t.CRH())&&(e.notesRef=i.first),t.iGM(i=t.CRH())&&(e.bestRef=i.first),t.iGM(i=t.CRH())&&(e.prosConsRef=i.first),t.iGM(i=t.CRH())&&(e.topicsRef=i.first)}},standalone:!0,features:[t.qOj,t.jDz],decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],["code4",""],[1,"list-decimal","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"list-decimal","px-10","text-sm"]],template:function(o,e){1&o&&(t.TgZ(0,"section",0)(1,"p",1),t._uU(2," Partial Hydration "),t.qZA(),t.TgZ(3,"div",2)(4,"p")(5,"span",3),t._uU(6,"Partial Hydration"),t.qZA(),t._uU(7," in Angular 19 provides selective rehydration of static server-rendered HTML, enabling fine-grained control over which parts of an application become interactive. This approach significantly improves performance by reducing the JavaScript needed for initial interactivity, prioritizing critical user interfaces, and optimizing for Core Web Vitals metrics. "),t.qZA(),t._UZ(8,"br"),t.TgZ(9,"div",4)(10,"div",5)(11,"button",6),t.NdJ("click",function(){return e.selectedTab=1}),t._uU(12," Notes "),t.qZA(),t.TgZ(13,"button",6),t.NdJ("click",function(){return e.selectedTab=2}),t._uU(14," Best Practices "),t.qZA(),t.TgZ(15,"button",6),t.NdJ("click",function(){return e.selectedTab=3}),t._uU(16," Pros and Cons "),t.qZA(),t.TgZ(17,"button",6),t.NdJ("click",function(){return e.selectedTab=4}),t._uU(18," Related Topics "),t.qZA()(),t.TgZ(19,"div",7),t.ynx(20,8),t.YNc(21,b,2,1,"div",9),t.YNc(22,w,2,1,"div",9),t.YNc(23,x,2,1,"div",9),t.YNc(24,S,2,1,"div",10),t.BQk(),t.qZA()()()(),t.YNc(25,M,179,12,"ng-template",null,11,t.W1O),t.YNc(27,k,81,0,"ng-template",null,12,t.W1O),t.YNc(29,D,138,0,"ng-template",null,13,t.W1O),t.YNc(31,R,88,0,"ng-template",null,14,t.W1O)),2&o&&(t.xp6(11),t.ekj("text-rose-300",1===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",2===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",3===e.selectedTab),t.xp6(2),t.ekj("text-rose-300",4===e.selectedTab),t.xp6(3),t.Q6J("ngSwitch",e.selectedTab),t.xp6(1),t.Q6J("ngSwitchCase",2),t.xp6(1),t.Q6J("ngSwitchCase",3),t.xp6(1),t.Q6J("ngSwitchCase",4))},dependencies:[s.ez,s.tP,s.RF,s.n9,s.ED,u._l,u.y$],styles:["p[_ngcontent-%COMP%]{line-height:1.5}"],changeDetection:0});const z=[{path:"",component:l}];class d{}d.\u0275fac=function(o){return new(o||d)},d.\u0275mod=t.oAB({type:d}),d.\u0275inj=t.cJS({imports:[s.ez,l,g.Bz.forChild(z)]})}}]);