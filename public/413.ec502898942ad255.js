"use strict";(self.webpackChunktailwind=self.webpackChunktailwind||[]).push([[413],{7413:(S,g,s)=>{s.r(g),s.d(g,{SignalComponentsComponent:()=>l});var r=s(6895),c=s(827),e=s(8256);const p=["notesRef"],m=["bestRef"],d=["prosConsRef"],Z=["topicsRef"];function _(t,i){1&t&&e.GkF(0)}function f(t,i){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,_,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const n=e.MAs(28);e.xp6(1),e.Q6J("ngTemplateOutlet",n)}}function h(t,i){1&t&&e.GkF(0)}function A(t,i){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,h,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const n=e.MAs(30);e.xp6(1),e.Q6J("ngTemplateOutlet",n)}}function U(t,i){1&t&&e.GkF(0)}function q(t,i){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,U,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const n=e.MAs(32);e.xp6(1),e.Q6J("ngTemplateOutlet",n)}}function T(t,i){1&t&&e.GkF(0)}function C(t,i){if(1&t&&(e.TgZ(0,"div"),e.YNc(1,T,1,0,"ng-container",15),e.qZA()),2&t){e.oxw();const n=e.MAs(26);e.xp6(1),e.Q6J("ngTemplateOutlet",n)}}const u=function(){return["typescript"]};function v(t,i){if(1&t){const n=e.EpF();e.TgZ(0,"p"),e._uU(1,"What are Signal-Based Components?"),e.qZA(),e.TgZ(2,"ul",16)(3,"li")(4,"strong"),e._uU(5,"Reactive Programming Model"),e.qZA(),e._uU(6,": Components built using Angular's signals system, offering fine-grained reactivity and improved change detection. "),e.qZA(),e.TgZ(7,"li")(8,"strong"),e._uU(9,"Simplified API"),e.qZA(),e._uU(10,": Streamlined API for inputs, outputs, models (two-way binding), and view queries. "),e.qZA(),e.TgZ(11,"li")(12,"strong"),e._uU(13,"Improved Performance"),e.qZA(),e._uU(14,": Better performance through fine-grained reactivity and more efficient change detection. "),e.qZA(),e.TgZ(15,"li")(16,"strong"),e._uU(17,"Enhanced Developer Experience"),e.qZA(),e._uU(18,": More intuitive programming model with a functional approach to reactivity. "),e.qZA()(),e._UZ(19,"br")(20,"br"),e.TgZ(21,"p"),e._uU(22,"Basic Signal Component Example"),e.qZA(),e.TgZ(23,"button",17),e.NdJ("click",function(){e.CHM(n);const a=e.MAs(26);return e.KtG(a.hidden=!a.hidden)}),e._uU(24,"code"),e.qZA(),e.TgZ(25,"span",18,19)(27,"div",20)(28,"span"),e._uU(29,"typescript"),e.qZA(),e._UZ(30,"span",21),e.qZA(),e.TgZ(31,"pre"),e._uU(32,"      "),e.TgZ(33,"code",22),e._uU(34,"\n      "),e.qZA(),e._uU(35,"\n    "),e.qZA()(),e._UZ(36,"br")(37,"br"),e.TgZ(38,"p"),e._uU(39,"Advanced Signal Component Features"),e.qZA(),e.TgZ(40,"button",17),e.NdJ("click",function(){e.CHM(n);const a=e.MAs(43);return e.KtG(a.hidden=!a.hidden)}),e._uU(41,"code"),e.qZA(),e.TgZ(42,"span",18,23)(44,"div",20)(45,"span"),e._uU(46,"typescript"),e.qZA(),e._UZ(47,"span",21),e.qZA(),e.TgZ(48,"pre"),e._uU(49,"      "),e.TgZ(50,"code",22),e._uU(51,"\n      "),e.qZA(),e._uU(52,"\n    "),e.qZA()(),e._UZ(53,"br")(54,"br"),e.TgZ(55,"p"),e._uU(56,"Performance Optimizations with Signal Components"),e.qZA(),e.TgZ(57,"button",17),e.NdJ("click",function(){e.CHM(n);const a=e.MAs(60);return e.KtG(a.hidden=!a.hidden)}),e._uU(58,"code"),e.qZA(),e.TgZ(59,"span",18,24)(61,"div",20)(62,"span"),e._uU(63,"typescript"),e.qZA(),e._UZ(64,"span",21),e.qZA(),e.TgZ(65,"pre"),e._uU(66,"      "),e.TgZ(67,"code",22),e._uU(68,"\n      "),e.qZA(),e._uU(69,"\n    "),e.qZA()(),e._UZ(70,"br")(71,"br"),e.TgZ(72,"p"),e._uU(73,"Angular 19 Signal Component System"),e.qZA(),e.TgZ(74,"button",17),e.NdJ("click",function(){e.CHM(n);const a=e.MAs(77);return e.KtG(a.hidden=!a.hidden)}),e._uU(75,"code"),e.qZA(),e.TgZ(76,"span",18,25)(78,"div",20)(79,"span"),e._uU(80,"typescript"),e.qZA(),e._UZ(81,"span",21),e.qZA(),e.TgZ(82,"pre"),e._uU(83,"      "),e.TgZ(84,"code",22),e._uU(85,"\n      "),e.qZA(),e._uU(86,"\n    "),e.qZA()(),e._UZ(87,"br")(88,"br"),e.TgZ(89,"p"),e._uU(90,"Key Features of Signal-Based Components in Angular 19"),e.qZA(),e.TgZ(91,"ol",26)(92,"li")(93,"strong"),e._uU(94,"Signal-Based Inputs and Outputs"),e.qZA(),e._uU(95,": "),e.TgZ(96,"ul",27)(97,"li"),e._uU(98,"Input signals with default values: "),e.TgZ(99,"code"),e._uU(100,"maxValue = input(100)"),e.qZA()(),e.TgZ(101,"li"),e._uU(102,"Required inputs: "),e.TgZ(103,"code"),e._uU(104,"userId = input.required<string>()"),e.qZA()(),e.TgZ(105,"li"),e._uU(106,"Input transforms for validation and conversion"),e.qZA(),e.TgZ(107,"li"),e._uU(108,"Output signals for events: "),e.TgZ(109,"code"),e._uU(110,"countChanged = output<number>()"),e.qZA()()()(),e.TgZ(111,"li")(112,"strong"),e._uU(113,"Model Signal for Two-Way Binding"),e.qZA(),e._uU(114,": "),e.TgZ(115,"ul",27)(116,"li"),e._uU(117,"Simplified two-way binding with model signals: "),e.TgZ(118,"code"),e._uU(119,"count = model(0)"),e.qZA()(),e.TgZ(120,"li"),e._uU(121,"Use with "),e.TgZ(122,"code"),e._uU(123,"[(property)]"),e.qZA(),e._uU(124," in templates for cleaner binding syntax"),e.qZA(),e.TgZ(125,"li"),e._uU(126,"Automatic update propagation both ways"),e.qZA()()(),e.TgZ(127,"li")(128,"strong"),e._uU(129,"View Queries as Signals"),e.qZA(),e._uU(130,": "),e.TgZ(131,"ul",27)(132,"li"),e._uU(133,"ViewChild as signal: "),e.TgZ(134,"code"),e._uU(135,"element = viewChild('elementRef')"),e.qZA()(),e.TgZ(136,"li"),e._uU(137,"ViewChildren as signal: "),e.TgZ(138,"code"),e._uU(139,"items = viewChildren('itemRef')"),e.qZA()(),e.TgZ(140,"li"),e._uU(141,"Reactive updates when queries change"),e.qZA()()(),e.TgZ(142,"li")(143,"strong"),e._uU(144,"Computed Values and Effects"),e.qZA(),e._uU(145,": "),e.TgZ(146,"ul",27)(147,"li"),e._uU(148,"Computed signals for derived state: "),e.TgZ(149,"code"),e._uU(150,"doubled = computed(() => count() * 2)"),e.qZA()(),e.TgZ(151,"li"),e._uU(152,"Effects for side effects: "),e.TgZ(153,"code"),e._uU(154),e.qZA()(),e.TgZ(155,"li"),e._uU(156,"Automatic cleanup of effects when component is destroyed"),e.qZA()()(),e.TgZ(157,"li")(158,"strong"),e._uU(159,"Dependency Injection Integration"),e.qZA(),e._uU(160,": "),e.TgZ(161,"ul",27)(162,"li"),e._uU(163,"Simplified DI with inject function: "),e.TgZ(164,"code"),e._uU(165,"service = inject(Service)"),e.qZA()(),e.TgZ(166,"li"),e._uU(167,"No more constructor parameter injection needed"),e.qZA(),e.TgZ(168,"li"),e._uU(169,"Better tree-shaking and improved bundle size"),e.qZA()()()(),e._UZ(170,"br")(171,"br"),e.TgZ(172,"p"),e._uU(173,"Performance Comparison: Signal Components vs NgOnChanges"),e.qZA(),e.TgZ(174,"table",28)(175,"thead")(176,"tr",29)(177,"th",30),e._uU(178,"Aspect"),e.qZA(),e.TgZ(179,"th",30),e._uU(180,"Signal Components"),e.qZA(),e.TgZ(181,"th",30),e._uU(182,"Traditional Components"),e.qZA()()(),e.TgZ(183,"tbody")(184,"tr",31)(185,"td",32),e._uU(186,"Change Detection"),e.qZA(),e.TgZ(187,"td",32),e._uU(188,"Fine-grained, only affected signals"),e.qZA(),e.TgZ(189,"td",32),e._uU(190,"Component-level, often causes unnecessary checks"),e.qZA()(),e.TgZ(191,"tr",33)(192,"td",32),e._uU(193,"Component Reactivity"),e.qZA(),e.TgZ(194,"td",32),e._uU(195,"Automatic, based on signal dependencies"),e.qZA(),e.TgZ(196,"td",32),e._uU(197,"Manual, requires ngOnChanges handling"),e.qZA()(),e.TgZ(198,"tr",31)(199,"td",32),e._uU(200,"Memory Usage"),e.qZA(),e.TgZ(201,"td",32),e._uU(202,"Lower, no change detection tree traversal"),e.qZA(),e.TgZ(203,"td",32),e._uU(204,"Higher, especially in large component trees"),e.qZA()(),e.TgZ(205,"tr",34)(206,"td",32),e._uU(207,"Bundle Size"),e.qZA(),e.TgZ(208,"td",32),e._uU(209,"Smaller due to tree-shaking improvements"),e.qZA(),e.TgZ(210,"td",32),e._uU(211,"Larger, especially with decorator metadata"),e.qZA()()()()}if(2&t){const n=e.oxw();e.xp6(33),e.Q6J("highlight",n.basicSignalComponentCode)("languages",e.DdM(10,u)),e.xp6(17),e.Q6J("highlight",n.signalComponentFeaturesCode)("languages",e.DdM(11,u)),e.xp6(17),e.Q6J("highlight",n.signalComponentPerformanceCode)("languages",e.DdM(12,u)),e.xp6(17),e.Q6J("highlight",n.v19EnhancementsCode)("languages",e.DdM(13,u)),e.xp6(70),e.AsE("effect(() => ","{"," ... ","}",")")}}function b(t,i){1&t&&(e.TgZ(0,"ol",35)(1,"li")(2,"strong",36),e._uU(3,"Design with Signals in Mind"),e.qZA(),e.TgZ(4,"ul",27)(5,"li")(6,"strong"),e._uU(7,"Signal-First Architecture"),e.qZA(),e._uU(8,": Start by defining your component's state as signals, and build from there. "),e.qZA(),e.TgZ(9,"li")(10,"strong"),e._uU(11,"Minimize Stateful Services"),e.qZA(),e._uU(12,": Prefer injecting stateless services and managing state with signals in components. "),e.qZA(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Single Source of Truth"),e.qZA(),e._uU(16,": Keep related state in one signal rather than spreading it across multiple signals. "),e.qZA()()(),e.TgZ(17,"li")(18,"strong",36),e._uU(19,"Optimize Computed Signals"),e.qZA(),e.TgZ(20,"ul",27)(21,"li")(22,"strong"),e._uU(23,"Keep Computations Pure"),e.qZA(),e._uU(24,": Avoid side effects in computed signals; use effects for side effects instead. "),e.qZA(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Granular Computations"),e.qZA(),e._uU(28,": Break complex computations into smaller, reusable computed signals. "),e.qZA(),e.TgZ(29,"li")(30,"strong"),e._uU(31,"Use Untracked When Needed"),e.qZA(),e._uU(32,": Use "),e.TgZ(33,"code"),e._uU(34,"untracked()"),e.qZA(),e._uU(35," to prevent unnecessary dependencies in computed signals. "),e.qZA()()(),e.TgZ(36,"li")(37,"strong",36),e._uU(38,"Manage Effects Carefully"),e.qZA(),e.TgZ(39,"ul",27)(40,"li")(41,"strong"),e._uU(42,"Return Cleanup Functions"),e.qZA(),e._uU(43,": Always return cleanup functions from effects when subscribing to external resources. "),e.qZA(),e.TgZ(44,"li")(45,"strong"),e._uU(46,"Avoid Complex Logic"),e.qZA(),e._uU(47,": Keep effects focused on side effects, not complex state transformations. "),e.qZA(),e.TgZ(48,"li")(49,"strong"),e._uU(50,"Batch Updates"),e.qZA(),e._uU(51,": Group signal updates to minimize the number of effect executions. "),e.qZA()()(),e.TgZ(52,"li")(53,"strong",36),e._uU(54,"Input/Output Best Practices"),e.qZA(),e.TgZ(55,"ul",27)(56,"li")(57,"strong"),e._uU(58,"Use Default Values"),e.qZA(),e._uU(59,": Provide sensible defaults for input signals when possible. "),e.qZA(),e.TgZ(60,"li")(61,"strong"),e._uU(62,"Consider Required Inputs"),e.qZA(),e._uU(63,": Use "),e.TgZ(64,"code"),e._uU(65,"input.required()"),e.qZA(),e._uU(66," for truly required inputs to catch missing inputs early. "),e.qZA(),e.TgZ(67,"li")(68,"strong"),e._uU(69,"Transform Inputs When Needed"),e.qZA(),e._uU(70,": Use input transform functions to validate or convert incoming values. "),e.qZA()()(),e.TgZ(71,"li")(72,"strong",36),e._uU(73,"Component Integration"),e.qZA(),e.TgZ(74,"ul",27)(75,"li")(76,"strong"),e._uU(77,"Use Models for Two-Way Binding"),e.qZA(),e._uU(78,": Leverage model signals for clean two-way binding between components. "),e.qZA(),e.TgZ(79,"li")(80,"strong"),e._uU(81,"Connect with Zoneless Applications"),e.qZA(),e._uU(82,": Signal components work perfectly with zoneless applications for maximum performance. "),e.qZA(),e.TgZ(83,"li")(84,"strong"),e._uU(85,"Combine with Partial Hydration"),e.qZA(),e._uU(86,": Use signal components with partial hydration for optimal SSR performance. "),e.qZA()()()())}function y(t,i){1&t&&(e.TgZ(0,"strong",36),e._uU(1," Pros: "),e.qZA(),e._UZ(2,"br"),e.TgZ(3,"ol",37)(4,"li")(5,"strong"),e._uU(6,"Performance Improvements"),e.qZA(),e.TgZ(7,"ul",27)(8,"li")(9,"span",3),e._uU(10,"Fine-Grained Reactivity"),e.qZA(),e._uU(11,": Only the parts of the UI that depend on changed signals are updated, reducing unnecessary work. "),e.qZA(),e.TgZ(12,"li")(13,"span",3),e._uU(14,"Simplified Change Detection"),e.qZA(),e._uU(15,": No need for OnPush strategy or managing change detection manually. "),e.qZA(),e.TgZ(16,"li")(17,"span",3),e._uU(18,"Smaller Bundle Size"),e.qZA(),e._uU(19,": Better tree-shaking and less decorator metadata lead to smaller application bundles. "),e.qZA()()(),e.TgZ(20,"li")(21,"strong"),e._uU(22,"Developer Experience"),e.qZA(),e.TgZ(23,"ul",27)(24,"li")(25,"span",3),e._uU(26,"Intuitive API"),e.qZA(),e._uU(27,": Clear, functional API for inputs, outputs, computed values, and side effects. "),e.qZA(),e.TgZ(28,"li")(29,"span",3),e._uU(30,"Improved Type Safety"),e.qZA(),e._uU(31,": Better TypeScript integration with less reliance on string literals and generics. "),e.qZA(),e.TgZ(32,"li")(33,"span",3),e._uU(34,"Clear Data Flow"),e.qZA(),e._uU(35,": Signal dependencies make it easier to understand and trace data flow in components. "),e.qZA()()(),e.TgZ(36,"li")(37,"strong"),e._uU(38,"Modern Reactivity Model"),e.qZA(),e.TgZ(39,"ul",27)(40,"li")(41,"span",3),e._uU(42,"Automatic Dependency Tracking"),e.qZA(),e._uU(43,": Computed signals and effects automatically track their dependencies. "),e.qZA(),e.TgZ(44,"li")(45,"span",3),e._uU(46,"Simplified Two-Way Binding"),e.qZA(),e._uU(47,": Model signals make two-way binding cleaner and more intuitive. "),e.qZA(),e.TgZ(48,"li")(49,"span",3),e._uU(50,"Reactive View Queries"),e.qZA(),e._uU(51,": ViewChild and ViewChildren as signals provide reactive access to DOM elements. "),e.qZA()()(),e.TgZ(52,"li")(53,"strong"),e._uU(54,"Integration with Angular 19 Features"),e.qZA(),e.TgZ(55,"ul",27)(56,"li")(57,"span",3),e._uU(58,"Zoneless Applications"),e.qZA(),e._uU(59,": Perfect for use in zoneless applications for ultimate performance. "),e.qZA(),e.TgZ(60,"li")(61,"span",3),e._uU(62,"Partial Hydration"),e.qZA(),e._uU(63,": Works seamlessly with partial hydration for optimized SSR applications. "),e.qZA(),e.TgZ(64,"li")(65,"span",3),e._uU(66,"Control Flow Integration"),e.qZA(),e._uU(67,": Clean integration with built-in control flow syntax for purely declarative templates. "),e.qZA()()()(),e._UZ(68,"br")(69,"br"),e.TgZ(70,"strong",36),e._uU(71," Cons: "),e.qZA(),e._UZ(72,"br"),e.TgZ(73,"ol",37)(74,"li")(75,"strong"),e._uU(76,"Learning Curve"),e.qZA(),e.TgZ(77,"ul",27)(78,"li")(79,"span",3),e._uU(80,"New Programming Model"),e.qZA(),e._uU(81,": Requires learning and adapting to a different way of building components. "),e.qZA(),e.TgZ(82,"li")(83,"span",3),e._uU(84,"Reactive Thinking"),e.qZA(),e._uU(85,": Developers need to think reactively, which may be challenging for some. "),e.qZA(),e.TgZ(86,"li")(87,"span",3),e._uU(88,"Migration Effort"),e.qZA(),e._uU(89,": Converting existing components to the signal-based approach requires effort. "),e.qZA()()(),e.TgZ(90,"li")(91,"strong"),e._uU(92,"Potential Pitfalls"),e.qZA(),e.TgZ(93,"ul",27)(94,"li")(95,"span",3),e._uU(96,"Signal Overuse"),e.qZA(),e._uU(97,": Creating too many fine-grained signals can lead to complex component logic. "),e.qZA(),e.TgZ(98,"li")(99,"span",3),e._uU(100,"Effect Side Effects"),e.qZA(),e._uU(101,": Improper use of effects can lead to infinite update loops or other unexpected behavior. "),e.qZA(),e.TgZ(102,"li")(103,"span",3),e._uU(104,"Mental Model Shift"),e.qZA(),e._uU(105,": Moving between traditional and signal-based components in the same application can be confusing. "),e.qZA()()(),e.TgZ(106,"li")(107,"strong"),e._uU(108,"Ecosystem Integration"),e.qZA(),e.TgZ(109,"ul",27)(110,"li")(111,"span",3),e._uU(112,"Library Support"),e.qZA(),e._uU(113,": Some third-party libraries may not yet be optimized for signal-based components. "),e.qZA(),e.TgZ(114,"li")(115,"span",3),e._uU(116,"Tools and Testing"),e.qZA(),e._uU(117,": Testing tools and methodologies may need updates to work optimally with signal components. "),e.qZA(),e.TgZ(118,"li")(119,"span",3),e._uU(120,"Documentation and Resources"),e.qZA(),e._uU(121,": Fewer examples and resources compared to traditional components (though rapidly improving). "),e.qZA()()(),e.TgZ(122,"li")(123,"strong"),e._uU(124,"Transition Challenges"),e.qZA(),e.TgZ(125,"ul",27)(126,"li")(127,"span",3),e._uU(128,"Mixed Component Types"),e.qZA(),e._uU(129,": Managing applications with both traditional and signal-based components can be challenging. "),e.qZA(),e.TgZ(130,"li")(131,"span",3),e._uU(132,"Training and Adoption"),e.qZA(),e._uU(133,": Teams need time and resources to adopt and become proficient with the new approach. "),e.qZA(),e.TgZ(134,"li")(135,"span",3),e._uU(136,"Legacy Integration"),e.qZA(),e._uU(137,": Integrating with legacy code or libraries optimized for the traditional component model. "),e.qZA()()()())}function w(t,i){1&t&&(e.TgZ(0,"ol",37)(1,"li")(2,"strong"),e._uU(3,"Signals"),e.qZA(),e.TgZ(4,"ul",27)(5,"li")(6,"strong",36),e._uU(7,"Description"),e.qZA(),e._uU(8,": Angular's reactive primitives for state management introduced in Angular 16+. "),e.qZA(),e.TgZ(9,"li")(10,"strong",36),e._uU(11,"Relation to Signal Components"),e.qZA(),e._uU(12,": Signal Components are built on and extend the basic signals system, providing a complete component model. "),e.qZA()()(),e.TgZ(13,"li")(14,"strong"),e._uU(15,"Zoneless Applications"),e.qZA(),e.TgZ(16,"ul",27)(17,"li")(18,"strong",36),e._uU(19,"Description"),e.qZA(),e._uU(20,": Angular applications that run without Zone.js, using explicit change detection. "),e.qZA(),e.TgZ(21,"li")(22,"strong",36),e._uU(23,"Relation to Signal Components"),e.qZA(),e._uU(24,": Signal Components provide the ideal programming model for zoneless applications, as they handle their own change detection. "),e.qZA()()(),e.TgZ(25,"li")(26,"strong"),e._uU(27,"Reactive Programming"),e.qZA(),e.TgZ(28,"ul",27)(29,"li")(30,"strong",36),e._uU(31,"Description"),e.qZA(),e._uU(32,": Programming paradigm focused on data streams and propagation of change. "),e.qZA(),e.TgZ(33,"li")(34,"strong",36),e._uU(35,"Relation to Signal Components"),e.qZA(),e._uU(36,": Signal Components implement reactive programming principles within the Angular component model. "),e.qZA()()(),e.TgZ(37,"li")(38,"strong"),e._uU(39,"Partial Hydration"),e.qZA(),e.TgZ(40,"ul",27)(41,"li")(42,"strong",36),e._uU(43,"Description"),e.qZA(),e._uU(44,": Technique to selectively hydrate server-rendered components based on need. "),e.qZA(),e.TgZ(45,"li")(46,"strong",36),e._uU(47,"Relation to Signal Components"),e.qZA(),e._uU(48,": Signal Components work well with partial hydration for fine-grained control over which parts of an app become interactive. "),e.qZA()()(),e.TgZ(49,"li")(50,"strong"),e._uU(51,"Two-Way Binding"),e.qZA(),e.TgZ(52,"ul",27)(53,"li")(54,"strong",36),e._uU(55,"Description"),e.qZA(),e._uU(56,": Data binding that works in both directions between parent and child components. "),e.qZA(),e.TgZ(57,"li")(58,"strong",36),e._uU(59,"Relation to Signal Components"),e.qZA(),e._uU(60,": Signal Components introduce model signals, a cleaner approach to two-way binding with "),e.TgZ(61,"code"),e._uU(62,"[(property)]"),e.qZA(),e._uU(63," syntax. "),e.qZA()()(),e.TgZ(64,"li")(65,"strong"),e._uU(66,"RxJS and Observables"),e.qZA(),e.TgZ(67,"ul",27)(68,"li")(69,"strong",36),e._uU(70,"Description"),e.qZA(),e._uU(71,": Library for reactive programming using Observables to compose asynchronous code. "),e.qZA(),e.TgZ(72,"li")(73,"strong",36),e._uU(74,"Relation to Signal Components"),e.qZA(),e._uU(75,": While different in API, both signals and RxJS provide reactive programming models, and can be used together. "),e.qZA()()(),e.TgZ(76,"li")(77,"strong"),e._uU(78,"Change Detection"),e.qZA(),e.TgZ(79,"ul",27)(80,"li")(81,"strong",36),e._uU(82,"Description"),e.qZA(),e._uU(83,": Angular's mechanism for updating the DOM when component data changes. "),e.qZA(),e.TgZ(84,"li")(85,"strong",36),e._uU(86,"Relation to Signal Components"),e.qZA(),e._uU(87,": Signal Components provide fine-grained, automatic change detection, eliminating the need for manual change detection management. "),e.qZA()()()())}class l{constructor(){this.selectedTab=1,this.basicSignalComponentCode="import { Component, input, output, model } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div>\n      <h2>Counter: {{ count() }}</h2>\n      <button (click)=\"increment()\">Increment</button>\n      <button (click)=\"decrement()\">Decrement</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  // Input signal with default value\n  max = input(100);\n\n  // Required input signal\n  min = input.required<number>();\n\n  // Model signal for two-way binding\n  count = model(0);\n\n  // Output signal for events\n  countChanged = output<number>();\n\n  increment() {\n    if (this.count() < this.max()) {\n      this.count.update(value => value + 1);\n      this.countChanged.emit(this.count());\n    }\n  }\n\n  decrement() {\n    if (this.count() > this.min()) {\n      this.count.update(value => value - 1);\n      this.countChanged.emit(this.count());\n    }\n  }\n}",this.signalComponentFeaturesCode="import { Component, input, output, model, viewChild, viewChildren, computed, effect, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ItemService } from './item.service';\n\n@Component({\n  selector: 'app-item-list',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div>\n      <h2>Items ({{ filteredItems().length }} of {{ items().length }})</h2>\n\n      <label>\n        Filter by category:\n        <select #categoryFilter (change)=\"category.set(categoryFilter.value)\">\n          <option value=\"\">All</option>\n          <option *ngFor=\"let cat of categories()\" [value]=\"cat\">{{ cat }}</option>\n        </select>\n      </label>\n\n      <ul>\n        <li *ngFor=\"let item of filteredItems()\" #itemRef>\n          {{ item.name }} - {{ item.category }}\n        </li>\n      </ul>\n\n      <p>Total value: {{ totalValue() }}</p>\n    </div>\n  `\n})\nexport class ItemListComponent {\n  // Inject service\n  private itemService = inject(ItemService);\n\n  // Input with transform\n  items = input<Item[]>([], {\n    transform: (items: Item[]) => items.sort((a, b) => a.name.localeCompare(b.name))\n  });\n\n  // View child as signal\n  categorySelect = viewChild<HTMLSelectElement>('categoryFilter');\n\n  // View children as signal\n  itemElements = viewChildren<HTMLLIElement>('itemRef');\n\n  // Local signal state\n  category = signal('');\n\n  // Computed values\n  categories = computed(() => {\n    const uniqueCategories = new Set<string>();\n    this.items().forEach(item => uniqueCategories.add(item.category));\n    return Array.from(uniqueCategories).sort();\n  });\n\n  filteredItems = computed(() => {\n    const currentCategory = this.category();\n    if (!currentCategory) return this.items();\n    return this.items().filter(item => item.category === currentCategory);\n  });\n\n  totalValue = computed(() => {\n    return this.filteredItems().reduce((sum, item) => sum + item.price, 0);\n  });\n\n  constructor() {\n    // Effect for side effects (e.g., analytics)\n    effect(() => {\n      this.itemService.logCategoryChange(this.category());\n    });\n\n    // Effect with cleanup\n    effect((onCleanup) => {\n      const handler = () => this.category.set('');\n      window.addEventListener('reset-filters', handler);\n\n      // Return cleanup function\n      onCleanup(() => {\n        window.removeEventListener('reset-filters', handler);\n      });\n    });\n  }\n}\n\ninterface Item {\n  name: string;\n  category: string;\n  price: number;\n}",this.signalComponentPerformanceCode="import { Component, input, computed, untracked, InputSignal } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-performance-example',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div>\n      <h2>Performance Optimized Component</h2>\n      <p>Active items: {{ activeItemCount() }}</p>\n      <p>Rendering {{ visibleItems().length }} of {{ untracked(items).length }} items</p>\n\n      <ul>\n        <li *ngFor=\"let item of visibleItems()\">\n          {{ item.name }} - {{ item.status }}\n        </li>\n      </ul>\n    </div>\n  `\n})\nexport class PerformanceExampleComponent {\n  // Input signals\n  items = input<Item[]>([]);\n  filterActive = input(true);\n\n  // Memoize expensive operations\n  private itemsMap = computed(() => {\n    console.log('Building items map - expensive operation');\n    const map = new Map<string, Item>();\n    this.items().forEach(item => map.set(item.id, item));\n    return map;\n  });\n\n  // Computed that depends on a subset of signals\n  activeItemCount = computed(() => {\n    // Using untracked to avoid dependency on the entire items array\n    // when we only care about the count of active items\n    return untracked(this.items).filter(item => item.status === 'active').length;\n  });\n\n  // Optimized computation that tracks only relevant dependencies\n  visibleItems = computed(() => {\n    const showActive = this.filterActive();\n\n    // Only re-compute when filterActive changes or items relevantly change\n    if (showActive) {\n      return this.items().filter(item => item.status === 'active');\n    } else {\n      return this.items();\n    }\n  });\n\n  // Getting a single item without tracking the entire items array\n  getItem(id: string): Item | undefined {\n    return this.itemsMap().get(id);\n  }\n}\n\ninterface Item {\n  id: string;\n  name: string;\n  status: 'active' | 'inactive';\n}",this.v19EnhancementsCode="import { Component, input, output, model, viewChild, computed, signal } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n// Angular 19 component (fully reactive, standalone by default)\n@Component({\n  selector: 'app-v19-counter',\n  // Standalone is now the default in Angular 19\n  // No need for imports array with automatic module detection\n  template: `\n    <div>\n      <h2>Enhanced Counter: {{ count() }}</h2>\n      <p>Squared value: {{ squared() }}</p>\n\n      <div class=\"controls\">\n        <button (click)=\"increment()\">Increment</button>\n        <button (click)=\"reset()\">Reset to Initial</button>\n      </div>\n\n      <div class=\"config\" *ngIf=\"showConfig()\">\n        <label>\n          Initial Value:\n          <input type=\"number\" [value]=\"initialValue()\"\n                (input)=\"setInitialValue($event)\">\n        </label>\n        <button (click)=\"applyInitialValue()\">Apply</button>\n      </div>\n\n      <button (click)=\"toggleConfig()\">\n        {{ showConfig() ? 'Hide' : 'Show' }} Config\n      </button>\n    </div>\n  `\n})\nexport class V19CounterComponent {\n  // Input with validation and transform\n  initialValue = input(0, {\n    // Additional type checking with alias support\n    alias: 'startValue',\n    transform: (value: number) => {\n      // Validate and transform input\n      return Math.max(0, Math.round(value));\n    }\n  });\n\n  // Private signals\n  #count = signal(this.initialValue());\n  #showConfig = signal(false);\n\n  // Public API (readonly for template)\n  count = this.#count.asReadonly();\n  showConfig = this.#showConfig.asReadonly();\n\n  // Two-way binding model\n  theme = model<'light' | 'dark'>('light');\n\n  // Computed value\n  squared = computed(() => this.count() * this.count());\n\n  // ViewChild as signal\n  counterDisplay = viewChild<HTMLHeadingElement>('counterDisplay');\n\n  // Methods\n  increment() {\n    this.#count.update(c => c + 1);\n  }\n\n  reset() {\n    this.#count.set(this.initialValue());\n  }\n\n  toggleConfig() {\n    this.#showConfig.update(show => !show);\n  }\n\n  setInitialValue(event: Event) {\n    const value = Number((event.target as HTMLInputElement).value);\n    this.initialValue.set(value);\n  }\n\n  applyInitialValue() {\n    this.reset();\n  }\n}"}}l.\u0275fac=function(i){return new(i||l)},l.\u0275cmp=e.Xpm({type:l,selectors:[["app-signal-components"]],viewQuery:function(i,n){if(1&i&&(e.Gf(p,5),e.Gf(m,5),e.Gf(d,5),e.Gf(Z,5)),2&i){let o;e.iGM(o=e.CRH())&&(n.notesRef=o.first),e.iGM(o=e.CRH())&&(n.bestRef=o.first),e.iGM(o=e.CRH())&&(n.prosConsRef=o.first),e.iGM(o=e.CRH())&&(n.topicsRef=o.first)}},standalone:!0,features:[e.jDz],decls:33,vars:12,consts:[[1,"p-4","text-sm"],[1,"heading-1","mb-2"],[1,"text-content"],[1,"text-zinc-50","tw-font-medium"],[1,"flex","flex-col"],[1,"flex","border-b","border-gray-200"],[1,"text-sky-400","hover:text-rose-400","font-semibold","py-2","px-4","border-b-2","border-transparent","hover:border-gray-500","focus:outline-none",3,"click"],[1,"p-4"],[3,"ngSwitch"],[4,"ngSwitchCase"],[4,"ngSwitchDefault"],["notesRef",""],["bestRef",""],["prosConsRef",""],["topicsRef",""],[4,"ngTemplateOutlet"],[1,"list-disc","pl-4","text-sm"],[1,"border","border-rose-400","rounded-md","px-1","text-sky-400",3,"click"],["hidden","","copyToClipboard",""],["code1",""],[1,"flex","flex-row","justify-between","items-center","bg-gray-900","px-4","py-2","relative","top-5"],[1,"copy-button-wrapper","bg-gray-700"],[3,"highlight","languages"],["code2",""],["code3",""],["code4",""],[1,"list-decimal","pl-4","text-sm"],[1,"list-disc","pl-4"],[1,"w-full","border-collapse","rounded-lg","overflow-hidden","shadow-md"],[1,"bg-gray-800","text-gray-100"],[1,"py-3","px-4","text-left"],[1,"border-b","border-gray-700","bg-gray-900","hover:bg-gray-800","transition-colors"],[1,"py-3","px-4"],[1,"border-b","border-gray-700","bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"bg-gray-950","hover:bg-gray-800","transition-colors"],[1,"list-decimal","px-4","text-sm"],[1,"text-sky-400"],[1,"list-decimal","px-10","text-sm"]],template:function(i,n){1&i&&(e.TgZ(0,"section",0)(1,"p",1),e._uU(2," Signal-Based Components "),e.qZA(),e.TgZ(3,"div",2)(4,"p")(5,"span",3),e._uU(6,"Signal-Based Components"),e.qZA(),e._uU(7," in Angular 19 introduce a fully reactive programming model for building web interfaces. This new component architecture leverages signals for fine-grained reactivity, offering improved performance, simplified two-way binding, and better developer experience through a streamlined API surface. "),e.qZA(),e._UZ(8,"br"),e.TgZ(9,"div",4)(10,"div",5)(11,"button",6),e.NdJ("click",function(){return n.selectedTab=1}),e._uU(12," Notes "),e.qZA(),e.TgZ(13,"button",6),e.NdJ("click",function(){return n.selectedTab=2}),e._uU(14," Best Practices "),e.qZA(),e.TgZ(15,"button",6),e.NdJ("click",function(){return n.selectedTab=3}),e._uU(16," Pros and Cons "),e.qZA(),e.TgZ(17,"button",6),e.NdJ("click",function(){return n.selectedTab=4}),e._uU(18," Related Topics "),e.qZA()(),e.TgZ(19,"div",7),e.ynx(20,8),e.YNc(21,f,2,1,"div",9),e.YNc(22,A,2,1,"div",9),e.YNc(23,q,2,1,"div",9),e.YNc(24,C,2,1,"div",10),e.BQk(),e.qZA()()()(),e.YNc(25,v,212,14,"ng-template",null,11,e.W1O),e.YNc(27,b,87,0,"ng-template",null,12,e.W1O),e.YNc(29,y,138,0,"ng-template",null,13,e.W1O),e.YNc(31,w,88,0,"ng-template",null,14,e.W1O)),2&i&&(e.xp6(11),e.ekj("text-rose-300",1===n.selectedTab),e.xp6(2),e.ekj("text-rose-300",2===n.selectedTab),e.xp6(2),e.ekj("text-rose-300",3===n.selectedTab),e.xp6(2),e.ekj("text-rose-300",4===n.selectedTab),e.xp6(3),e.Q6J("ngSwitch",n.selectedTab),e.xp6(1),e.Q6J("ngSwitchCase",2),e.xp6(1),e.Q6J("ngSwitchCase",3),e.xp6(1),e.Q6J("ngSwitchCase",4))},dependencies:[r.ez,r.tP,r.RF,r.n9,r.ED,c._l,c.y$],styles:["p[_ngcontent-%COMP%]{line-height:1.5}"]})}}]);