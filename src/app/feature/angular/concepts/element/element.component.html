<section class="p-4 text-sm">
  <p class="heading-1 mb-2">
    Element
  </p>

  <div class="text-content">
    <p>
      <span class="text-zinc-50 tw-font-medium">Element</span>
      in Angular 19 refers to DOM elements that applications interact with through HTML templates. Angular provides enhanced ways to work with DOM elements through template reference variables, ElementRef, and the signals-based reactive system. Modern approaches for element interaction include leveraging the Renderer2 service, improved lifecycle hooks, and integrating with new features like effect() for DOM manipulation.
    </p>

    <br>

    <div class="flex flex-col">
      <div class="flex border-b border-gray-200">
        <button (click)="selectedTab = 1" [class.text-rose-300]="selectedTab===1" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Notes
        </button>
        <button (click)="selectedTab = 2" [class.text-rose-300]="selectedTab===2" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Best Practices
        </button>
        <button (click)="selectedTab = 3" [class.text-rose-300]="selectedTab===3" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Pros and Cons
        </button>
        <button (click)="selectedTab = 4" [class.text-rose-300]="selectedTab===4" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Related Topics
        </button>
      </div>
      <div class="p-4">
        <ng-container [ngSwitch]="selectedTab">
          <div *ngSwitchCase="2">
            <ng-container *ngTemplateOutlet="bestRef;"></ng-container>
          </div>
          <div *ngSwitchCase="3">
            <ng-container *ngTemplateOutlet="prosConsRef;"></ng-container>
          </div>
          <div *ngSwitchCase="4">
            <ng-container *ngTemplateOutlet="topicsRef"></ng-container>
          </div>
          <div *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="notesRef"></ng-container>
          </div>
        </ng-container>
      </div>
    </div>
  </div>
</section>


<ng-template #notesRef>
  <p>What are Elements in Angular?</p>
  <ul class="list-disc pl-4 text-sm">
    <li>
      <strong>Definition</strong>:
      DOM elements in Angular are HTML elements that form the structure of the user interface. Angular provides various ways to access, manipulate, and interact with these elements programmatically.
    </li>
    <li>
      <strong>Template Reference Variables</strong>:
      Angular allows creating references to DOM elements using the # syntax in templates, which can then be accessed in the component class.
    </li>
    <li>
      <strong>ElementRef</strong>:
      A wrapper around a native DOM element that provides access to the element from component code.
    </li>
    <li>
      <strong>Renderer2</strong>:
      A service that provides an abstraction layer for manipulating DOM elements safely, which is particularly important for platform-independent applications.
    </li>
  </ul>

  <br>
  <br>

  <p>Element Improvements in Angular 19</p>
  <ol class="list-decimal pl-4 text-sm">
    <li>
      <strong>Signal-Based DOM Updates</strong>:
      <ul class="list-disc pl-4">
        <li>Angular 19 introduces improved integration between the signals system and DOM manipulation, allowing more efficient and reactive DOM updates through the effect() function that automatically tracks dependencies.</li>
      </ul>
    </li>
    <li>
      <strong>Enhanced Lifecycle Hooks</strong>:
      <ul class="list-disc pl-4">
        <li>New AfterRender and AfterNextRender hooks provide better control over DOM operations, ensuring they happen at the optimal time in the rendering cycle.</li>
      </ul>
    </li>
    <li>
      <strong>Improved Memory Management</strong>:
      <ul class="list-disc pl-4">
        <li>Angular 19 offers better garbage collection and memory handling for DOM elements, particularly with the takeUntilDestroyed operator from @angular/core/rxjs-interop for automatic cleanup.</li>
      </ul>
    </li>
    <li>
      <strong>TypeScript Integration</strong>:
      <ul class="list-disc pl-4">
        <li>Stronger typing for ElementRef with improved generic support, allowing better type safety when working with specific element types.</li>
      </ul>
    </li>
    <li>
      <strong>Zone-less DOM Updates</strong>:
      <ul class="list-disc pl-4">
        <li>Angular 19's signal architecture allows DOM manipulations to happen outside of Zone.js, improving performance for element manipulations.</li>
      </ul>
    </li>
  </ol>

  <br>
  <br>

  <p>Working with Elements in Angular 19</p>
  <ol class="list-decimal px-10 text-sm">
    <li>
      <strong>Basic Element Reference</strong>:
      Using ViewChild to get a reference to a DOM element.

      <button (click)="code_1_ref.hidden = !code_1_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code_1_ref hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_1"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>ElementRef with Signals</strong>:
      Combining ElementRef with Angular 19's signals system.

      <button (click)="code_2_ref.hidden = !code_2_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code_2_ref hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_2"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>Optimized Element Access</strong>:
      Efficient access to DOM elements with rxjs-interop.

      <button (click)="code_3_ref.hidden = !code_3_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code_3_ref hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_3"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>Renderer2 for Safe DOM Manipulation</strong>:
      Using Renderer2 for cross-platform DOM operations.

      <button (click)="code_4_ref.hidden = !code_4_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code_4_ref hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_4"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
  </ol>

  <br>
  <br>

  <p>Element Access Methods Comparison</p>
  <table class="w-full border-collapse rounded-lg overflow-hidden shadow-md">
    <thead>
      <tr class="bg-gray-800 text-gray-100">
        <th class="py-3 px-4 text-left">Method</th>
        <th class="py-3 px-4 text-left">Use Case</th>
        <th class="py-3 px-4 text-left">Pros</th>
        <th class="py-3 px-4 text-left">Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Template Reference Variables (#var)</td>
        <td class="py-3 px-4">Simple element access within templates</td>
        <td class="py-3 px-4">Direct, clean syntax</td>
        <td class="py-3 px-4">Limited to template scope</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">ViewChild/ViewChildren</td>
        <td class="py-3 px-4">Component class access to elements</td>
        <td class="py-3 px-4">Type-safe, integrated with lifecycle</td>
        <td class="py-3 px-4">Only available after view init</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">ElementRef</td>
        <td class="py-3 px-4">Direct DOM manipulation</td>
        <td class="py-3 px-4">Simple, direct access to native element</td>
        <td class="py-3 px-4">Not platform agnostic</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Renderer2</td>
        <td class="py-3 px-4">Safe, cross-platform DOM manipulation</td>
        <td class="py-3 px-4">Platform independent, security</td>
        <td class="py-3 px-4">More verbose</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Signal-based effects</td>
        <td class="py-3 px-4">Reactive DOM updates</td>
        <td class="py-3 px-4">Automatic tracking, fine-grained updates</td>
        <td class="py-3 px-4">New API, requires understanding signals</td>
      </tr>
    </tbody>
  </table>
</ng-template>


<ng-template #bestRef>
  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong class="text-sky-400">Use Renderer2 Instead of Direct DOM Manipulation</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Platform Independence</strong>:
          Always use Renderer2 for DOM manipulations instead of direct ElementRef operations. This ensures your application works correctly across different platforms (browser, server-side rendering, web workers).
        </li>
        <li>
          <strong>Security</strong>:
          Renderer2 helps prevent XSS vulnerabilities by providing a secure abstraction over DOM operations. Direct manipulation of nativeElement can bypass Angular's security mechanisms.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Leverage Signals for DOM Updates</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Reactive DOM Updates</strong>:
          Use Angular 19's signal system with effects for reactive DOM updates. This approach automatically tracks dependencies and only updates elements when relevant data changes.

          <button (click)="code_5_ref.hidden = !code_5_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

          <span #code_5_ref hidden copyToClipboard>
            <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
              <span>typescript</span>
              <span class="copy-button-wrapper bg-gray-700"></span>
            </div>

            <pre>
              <code
                [highlight]="code_5"
                [languages]="['typescript']">
              </code>
            </pre>
          </span>
        </li>
        <li>
          <strong>Zone-less Applications</strong>:
          In Angular 19's zone-less mode, combine signals and effects for DOM manipulations to ensure changes are properly tracked without Zone.js.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Optimize Performance</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Lazy Element Initialization</strong>:
          Use Intersection Observer API for elements that don't need to be initialized until they're visible, reducing initial rendering time and memory usage.

          <button (click)="code_6_ref.hidden = !code_6_ref.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

          <span #code_6_ref hidden copyToClipboard>
            <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
              <span>typescript</span>
              <span class="copy-button-wrapper bg-gray-700"></span>
            </div>

            <pre>
              <code
                [highlight]="code_6"
                [languages]="['typescript']">
              </code>
            </pre>
          </span>
        </li>
        <li>
          <strong>Avoid Excessive DOM Operations</strong>:
          Batch DOM operations and minimize direct manipulations to prevent layout thrashing. Use debounce/throttle for frequent updates triggered by user interactions.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Clean Up Element References</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Automatic Cleanup</strong>:
          Use the takeUntilDestroyed operator from @angular/core/rxjs-interop for automatic cleanup of subscriptions related to element events.
        </li>
        <li>
          <strong>Explicit Destruction</strong>:
          Implement OnDestroy and properly clean up any manual event listeners, observers, or third-party integrations with DOM elements.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Type Safety</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Use ElementRef with Type Parameters</strong>:
          Always specify the correct type when working with ElementRef to get better type safety and IDE support.
          <pre><code class="text-xs">@ViewChild('myInput') myInput!: ElementRef&lt;HTMLInputElement&gt;;</code></pre>
        </li>
        <li>
          <strong>Create Typed Wrappers</strong>:
          For complex elements with multiple operations, create typed wrapper services that encapsulate DOM manipulation logic.
        </li>
      </ul>
    </li>
  </ol>
</ng-template>


<ng-template #prosConsRef>
  <strong class="text-sky-400">
    Pros of Angular 19's Element Handling:
  </strong>

  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong>Signal Integration</strong>
      <ul class="list-disc pl-4">
        <li>
          Angular 19's signal system integrates seamlessly with DOM elements, allowing for reactive updates through effects that automatically track dependencies and update only when needed, improving performance and code clarity.
        </li>
      </ul>
    </li>
    <li>
      <strong>Improved Lifecycle Hooks</strong>
      <ul class="list-disc pl-4">
        <li>
          The new AfterRender and AfterNextRender hooks provide precise timing control for DOM operations, ensuring that element manipulations happen at the optimal point in the rendering cycle.
        </li>
      </ul>
    </li>
    <li>
      <strong>Better TypeScript Integration</strong>
      <ul class="list-disc pl-4">
        <li>
          Enhanced type safety with generics for ElementRef and improved static analysis capabilities make working with DOM elements more reliable and provide better tooling support.
        </li>
      </ul>
    </li>
    <li>
      <strong>Automatic Cleanup Utilities</strong>
      <ul class="list-disc pl-4">
        <li>
          Tools like takeUntilDestroyed from @angular/core/rxjs-interop simplify memory management when working with element references and event subscriptions, reducing memory leaks.
        </li>
      </ul>
    </li>
    <li>
      <strong>Zone-less Performance</strong>
      <ul class="list-disc pl-4">
        <li>
          Angular 19's support for zone-less applications allows for more efficient DOM updates without the overhead of Zone.js change detection, particularly beneficial for frequent element manipulations.
        </li>
      </ul>
    </li>
  </ol>

  <br>

  <strong class="text-sky-400">
    Cons and Challenges:
  </strong>

  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong>API Complexity</strong>
      <ul class="list-disc pl-4">
        <li>
          Multiple approaches to element handling (template references, ViewChild, ElementRef, Renderer2, signals) can create confusion for developers about which approach to use in different scenarios.
        </li>
      </ul>
    </li>
    <li>
      <strong>Learning Curve</strong>
      <ul class="list-disc pl-4">
        <li>
          The new signal-based reactivity system for DOM updates requires learning new patterns and understanding reactive programming concepts, particularly for developers familiar with the older change detection system.
        </li>
      </ul>
    </li>
    <li>
      <strong>Abstraction Overhead</strong>
      <ul class="list-disc pl-4">
        <li>
          Using Renderer2 and Angular's DOM abstraction layers adds some verbosity and complexity compared to direct DOM manipulation, though this trade-off is necessary for security and platform independence.
        </li>
      </ul>
    </li>
    <li>
      <strong>Timing Challenges</strong>
      <ul class="list-disc pl-4">
        <li>
          Working with DOM elements can still present timing challenges, particularly when integrating with third-party libraries that directly manipulate the DOM outside of Angular's lifecycle.
        </li>
      </ul>
    </li>
    <li>
      <strong>Server-Side Rendering Considerations</strong>
      <ul class="list-disc pl-4">
        <li>
          When using SSR with Angular Universal, DOM element access requires special handling as the DOM doesn't exist on the server, adding complexity to components that heavily rely on direct element manipulation.
        </li>
      </ul>
    </li>
  </ol>
</ng-template>


<ng-template #topicsRef>
  <p>Related Angular 19 Topics:</p>
  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong>ViewChild and ViewChildren</strong>:
      <p>
        Decorators for accessing DOM elements or directives from the component class that provide a structured way to work with elements in the template.
      </p>
    </li>
    <li>
      <strong>ContentChild and ContentChildren</strong>:
      <p>
        Similar to ViewChild/ViewChildren but used for projected content, allowing components to interact with elements passed through content projection (ng-content).
      </p>
    </li>
    <li>
      <strong>Component Lifecycle Hooks</strong>:
      <p>
        Understanding lifecycle hooks like AfterViewInit, AfterViewChecked, AfterRender, and AfterNextRender that are critical for proper timing of DOM element access and manipulation.
      </p>
    </li>
    <li>
      <strong>Signal Effects</strong>:
      <p>
        Angular 19's effect() function for creating reactive computations that automatically track signal dependencies and can be used for DOM updates based on state changes.
      </p>
    </li>
    <li>
      <strong>Zone-less Applications</strong>:
      <p>
        Building Angular applications without Zone.js and how this impacts element manipulation, focusing on explicit change detection and signal-based reactivity.
      </p>
    </li>
    <li>
      <strong>Angular Custom Elements</strong>:
      <p>
        Creating reusable web components from Angular components using the @angular/elements package, which is different from but related to working with DOM elements.
      </p>
    </li>
    <li>
      <strong>Renderer2 and Rendering Architecture</strong>:
      <p>
        Understanding Angular's rendering pipeline and how Renderer2 provides a platform-independent abstraction for DOM operations.
      </p>
    </li>
  </ol>
</ng-template>
