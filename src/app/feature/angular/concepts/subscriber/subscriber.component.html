<section class="p-4 text-sm">
  <p class="heading-1 mb-2">
    Subscribers in Angular
  </p>

  <div class="text-content">
    <p>
      <span class="text-zinc-50 tw-font-medium">Subscribers</span>
      in Angular 19 are objects that consume values emitted by Observables. With the introduction of Angular's reactive programming model, Subscribers play a crucial role in handling asynchronous operations, managing component state, and implementing reactive patterns efficiently.
    </p>

    <br>

    <div class="flex flex-col">
      <div class="flex border-b border-gray-200">
        <button  (click)="selectedTab = 1" [class.text-rose-300]="selectedTab===1" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Notes
        </button>
        <button  (click)="selectedTab = 2" [class.text-rose-300]="selectedTab===2" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Best Practices
        </button>
        <button  (click)="selectedTab = 3" [class.text-rose-300]="selectedTab===3" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Pros and Cons
        </button>
        <button  (click)="selectedTab = 4" [class.text-rose-300]="selectedTab===4" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Related Topics
        </button>
      </div>
      <div class="p-4">
        <ng-container [ngSwitch]="selectedTab">
          <div *ngSwitchCase="2">
            <ng-container *ngTemplateOutlet="bestRef;"></ng-container>
          </div>
          <div *ngSwitchCase="3">
            <ng-container *ngTemplateOutlet="prosConsRef;"></ng-container>
          </div>
          <div *ngSwitchCase="4">
            <ng-container *ngTemplateOutlet="topicsRef"></ng-container>
          </div>
          <div *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="notesRef"></ng-container>
          </div>
        </ng-container>
      </div>
    </div>

  </div>
</section>


<ng-template #notesRef>
  <p>Understanding Subscribers in Angular 19</p>
  <ul class="list-disc pl-4 text-sm">
    <li>
      <strong>Definition</strong>:
      A Subscriber is an object that represents a consumer of values provided by an Observable. It implements the Observer interface and defines how to handle the data and notifications sent by the Observable.
    </li>
    <li>
      <strong>Core Components</strong>:
      Subscribers contain three callback methods: next() for receiving values, error() for handling errors, and complete() for receiving completion notifications.
    </li>
    <li>
      <strong>Memory Management</strong>:
      Proper handling of Subscribers is crucial to avoid memory leaks in Angular applications, especially with long-lived components.
    </li>
    <li>
      <strong>Reactive Pattern</strong>:
      Subscribers enable the reactive programming paradigm in Angular, allowing for declarative, event-based code.
    </li>
  </ul>

  <br>
  <br>

  <p>Subscriber Enhancements in Angular 19</p>
  <ol class="list-decimal pl-4 text-sm">
    <li>
      <strong>Signal Integration</strong>:
      <ul class="list-disc pl-4">
        <li>Angular 19 integrates Signals with RxJS Observables, providing a seamless bridge between the two reactive models with optimized subscriber management.</li>
      </ul>
    </li>
    <li>
      <strong>Improved Subscription Management</strong>:
      <ul class="list-disc pl-4">
        <li>New utilities like <code>toSignal()</code> and <code>fromObservable()</code> enable easier conversion between Signals and Observables, with automatic subscription handling.</li>
      </ul>
    </li>
    <li>
      <strong>Zoneless Subscriptions</strong>:
      <ul class="list-disc pl-4">
        <li>Angular 19 supports zoneless subscriptions that work seamlessly with the new zoneless change detection, improving performance by reducing unnecessary change detection cycles.</li>
      </ul>
    </li>
    <li>
      <strong>Functional API for Subscribers</strong>:
      <ul class="list-disc pl-4">
        <li>New functional APIs for creating and managing subscribers with less boilerplate code and improved type safety, complementing Angular's move toward functional patterns.</li>
      </ul>
    </li>
    <li>
      <strong>Auto-Unsubscription</strong>:
      <ul class="list-disc pl-4">
        <li>New declarative patterns for automatic unsubscription management, reducing the risk of memory leaks and simplifying component cleanup.</li>
      </ul>
    </li>
  </ol>

  <br>
  <br>

  <p>Common Subscriber Patterns</p>
  <ol class="list-decimal pl-4 text-sm">
    <li>
      Creating a Subscriber

      <button (click)="code1.hidden = !code1.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code1 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_1"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>

    </li>
    <li>
      Unsubscribing from a Subscriber

      <button (click)="code2.hidden = !code2.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code2 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_2"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>

    </li>
    <li>
      Checking if a Subscriber is Unsubscribed

      <button (click)="code3.hidden = !code3.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code3 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_3"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>

    </li>
    <li>
      Using AsyncPipe to Subscribe to an Observable

      <button (click)="code4.hidden = !code4.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code4 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_4"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>

    </li>
    <li>
      Using Operators with Subscribers

      <button (click)="code5.hidden = !code5.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code5 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_5"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>

    </li>
  </ol>

  <br>
  <br>

  <p>New Signal-Based Alternatives in Angular 19</p>
  <table class="w-full border-collapse rounded-lg overflow-hidden shadow-md">
    <thead>
      <tr class="bg-gray-800 text-gray-100">
        <th class="py-3 px-4 text-left">RxJS Pattern</th>
        <th class="py-3 px-4 text-left">Signal Alternative</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4"><code>subscribe()</code> with callbacks</td>
        <td class="py-3 px-4"><code>toSignal(observable)</code> with computed signals</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4"><code>BehaviorSubject</code></td>
        <td class="py-3 px-4"><code>signal(initialValue)</code></td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4"><code>combineLatest</code></td>
        <td class="py-3 px-4"><code>computed(() => ...)</code> with multiple signals</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4"><code>takeUntil(destroy$)</code></td>
        <td class="py-3 px-4">Automatic cleanup with injection context</td>
      </tr>
    </tbody>
  </table>

</ng-template>


<ng-template #bestRef>
  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong class="text-sky-400">Always Unsubscribe</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Implement ngOnDestroy</strong>:
          Always unsubscribe from all active subscriptions in the ngOnDestroy lifecycle hook to prevent memory leaks.
        </li>
        <li>
          <strong>Use takeUntil Pattern</strong>:
          Consider using the takeUntil operator with a destroy$ subject for cleaner subscription management.
        </li>
        <li>
          <strong>Consider Signal Alternatives</strong>:
          In Angular 19, consider using signals with automatic cleanup instead of manual subscription management.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Leverage AsyncPipe</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Template Subscriptions</strong>:
          Use the AsyncPipe in templates whenever possible as it handles subscription and unsubscription automatically.
        </li>
        <li>
          <strong>Combine with *ngIf</strong>:
          Use AsyncPipe with *ngIf as="variable" to handle null/undefined values gracefully.
        </li>
        <li>
          <strong>Consider toSignal()</strong>:
          In Angular 19, consider using toSignal() to convert observables to signals for template use.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Error Handling</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Always Handle Errors</strong>:
          Always provide an error callback or use catchError operator to handle potential errors in your observable streams.
        </li>
        <li>
          <strong>Global Error Handling</strong>:
          Consider implementing a global error handling strategy for observables using RxJS operators and Angular's ErrorHandler.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">State Management</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Single Data Source</strong>:
          Maintain a single source of truth using BehaviorSubject or Signal for state that needs to be shared.
        </li>
        <li>
          <strong>Immutable Updates</strong>:
          When updating state in a subscriber's next callback, create new object references instead of mutating existing ones.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Performance Optimization</strong>:
      <ul class="list-disc pl-4">
        <li>
          <strong>Filter Unnecessary Emissions</strong>:
          Use operators like distinctUntilChanged to filter out duplicate values and reduce change detection cycles.
        </li>
        <li>
          <strong>Debounce User Input</strong>:
          Use debounceTime or throttleTime for handling frequent events like user input to reduce processing overhead.
        </li>
        <li>
          <strong>Consider Zoneless Approach</strong>:
          In Angular 19, use signal-based patterns or explicitly run outside Angular's zone for performance-critical operations.
        </li>
      </ul>
    </li>
  </ol>
</ng-template>


<ng-template #prosConsRef>
  <strong class="text-sky-400">
    Pros:
  </strong>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      Subscribers provide a powerful mechanism for handling asynchronous operations and event streams in Angular applications.
    </li>
    <li>
      They enable reactive programming patterns, allowing your app to respond to data changes and user inputs in a declarative way.
    </li>
    <li>
      RxJS operators can be composed with Subscribers to transform, filter, and combine data streams with sophisticated logic.
    </li>
    <li>
      Angular's integration with RxJS provides built-in solutions for common patterns like HTTP requests, form handling, and event management.
    </li>
    <li>
      In Angular 19, the new integration between RxJS and Signals provides more flexible options for reactive programming.
    </li>
  </ol>

  <br>

  <strong class="text-sky-400">
    Cons:
  </strong>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      Subscribers can cause memory leaks if not properly managed with appropriate unsubscription strategies.
    </li>
    <li>
      Learning curve for RxJS and reactive programming concepts can be steep for developers new to the paradigm.
    </li>
    <li>
      Debugging complex observable chains and subscriber logic can be challenging without specialized tools or knowledge.
    </li>
    <li>
      Overuse of subscribers for simple state management can lead to unnecessary complexity compared to signal-based alternatives.
    </li>
    <li>
      Performance overhead can occur with improper use, especially when triggering unnecessary change detection cycles.
    </li>
  </ol>


  <br>

  <p>
    In Angular 19, the ecosystem offers more choices between traditional RxJS-based subscribers and the new signal-based approach. While subscribers remain powerful for complex asynchronous scenarios, signals provide a simpler and more performant alternative for many common use cases with automatic cleanup and better integration with Angular's rendering engine.
  </p>

</ng-template>


<ng-template #topicsRef>
  <p>
    Related topics to Angular Subscribers in Angular 19:
  </p>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      <strong>Signals</strong>
      <p>
        Angular 19's Signal API provides a modern alternative to RxJS Observables and Subscribers for many use cases, with better performance characteristics and simpler syntax.
      </p>
    </li>
    <li>
      <strong>RxJS 8 Integration</strong>
      <p>
        Angular 19 integrates with RxJS 8, bringing improved type safety, better performance, and new interoperability features between RxJS and Angular's Signals.
      </p>
    </li>
    <li>
      <strong>Zoneless Change Detection</strong>
      <p>
        Angular 19's zoneless change detection model works seamlessly with both Signals and Subscribers, allowing for more predictable and performant state updates without zone.js.
      </p>
    </li>
    <li>
      <strong>Injection Context Cleanup</strong>
      <p>
        Angular 19 introduces a new injection context-based cleanup mechanism that can simplify subscription management compared to traditional takeUntil patterns.
      </p>
    </li>
    <li>
      <strong>Effect System</strong>
      <p>
        Angular 19's effect system provides a declarative way to respond to Signal changes, offering an alternative to Subscriber-based approaches for many reactive scenarios.
      </p>
    </li>
  </ol>
</ng-template>

