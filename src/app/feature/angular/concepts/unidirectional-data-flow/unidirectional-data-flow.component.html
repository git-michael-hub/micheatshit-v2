<section class="p-4 text-sm">
  <p class="heading-1 mb-2">
    Unidirectional Data Flow
  </p>

  <div class="text-content">
    <p>
      <span class="text-zinc-50 tw-font-medium">Unidirectional Data Flow</span>
      in Angular 19 refers to the one-way flow of data through the application, ensuring predictable state changes and simplified debugging. This architectural pattern enforces a clear direction of data movement from parent to child components, through inputs, events, and services, maintaining application stability while enhancing performance and maintainability.
    </p>

    <br>

    <div class="flex flex-col">
      <div class="flex border-b border-gray-200">
        <button (click)="selectedTab = 1" [class.text-rose-300]="selectedTab===1" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Notes
        </button>
        <button (click)="selectedTab = 2" [class.text-rose-300]="selectedTab===2" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Best Practices
        </button>
        <button (click)="selectedTab = 3" [class.text-rose-300]="selectedTab===3" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Pros and Cons
        </button>
        <button (click)="selectedTab = 4" [class.text-rose-300]="selectedTab===4" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Related Topics
        </button>
      </div>
      <div class="p-4">
        <ng-container [ngSwitch]="selectedTab">
          <div *ngSwitchCase="2">
            <ng-container *ngTemplateOutlet="bestRef;"></ng-container>
          </div>
          <div *ngSwitchCase="3">
            <ng-container *ngTemplateOutlet="prosConsRef;"></ng-container>
          </div>
          <div *ngSwitchCase="4">
            <ng-container *ngTemplateOutlet="topicsRef"></ng-container>
          </div>
          <div *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="notesRef"></ng-container>
          </div>
        </ng-container>
      </div>
    </div>

  </div>
</section>

<ng-template #notesRef>
  <p>Core Principles of Unidirectional Data Flow in Angular 19</p>
  <ul class="list-disc pl-4 text-sm">
    <li>
      <strong>Data Flows Down</strong>:
      Parents pass data to children via property binding (inputs), ensuring a clear hierarchy of data propagation.
    </li>
    <li>
      <strong>Events Flow Up</strong>:
      Children communicate with parents through events (outputs), maintaining a predictable pattern of interaction.
    </li>
    <li>
      <strong>Single Source of Truth</strong>:
      Data is owned by a single component/service, reducing conflicts and ensuring consistency across the application.
    </li>
    <li>
      <strong>Immutable Data Patterns</strong>:
      Changes create new data references rather than modifying existing ones, enhancing predictability and stability.
    </li>
  </ul>

  <br>
  <br>

  <p>Implementation in Angular 19</p>
  <ol class="list-decimal pl-4 text-sm">
    <li>
      <strong>@Input() Binding</strong>:
      <ul class="list-disc pl-4">
        <li>Parent components pass data to children through property bindings using the @Input() decorator.</li>

        <button (click)="code1.hidden = !code1.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

        <span #code1 hidden copyToClipboard>
          <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
            <span>typescript</span>
            <span class="copy-button-wrapper bg-gray-700"></span>
          </div>

          <pre>
            <code
              [highlight]="code_1"
              [languages]="['typescript']">
            </code>
          </pre>
        </span>
      </ul>
    </li>
    <li>
      <strong>@Output() Events</strong>:
      <ul class="list-disc pl-4">
        <li>Child components emit events to their parents using EventEmitters with the @Output() decorator.</li>

        <button (click)="code2.hidden = !code2.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

        <span #code2 hidden copyToClipboard>
          <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
            <span>typescript</span>
            <span class="copy-button-wrapper bg-gray-700"></span>
          </div>

          <pre>
            <code
              [highlight]="code_2"
              [languages]="['typescript']">
            </code>
          </pre>
        </span>
      </ul>
    </li>
    <li>
      <strong>Services and Stores</strong>:
      <ul class="list-disc pl-4">
        <li>State management solutions maintain a unidirectional flow through streams (RxJS) or signals.</li>

        <button (click)="code3.hidden = !code3.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

        <span #code3 hidden copyToClipboard>
          <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
            <span>typescript</span>
            <span class="copy-button-wrapper bg-gray-700"></span>
          </div>

          <pre>
            <code
              [highlight]="code_3"
              [languages]="['typescript']">
            </code>
          </pre>
        </span>
      </ul>
    </li>
    <li>
      <strong>Signals in Angular 19</strong>:
      <ul class="list-disc pl-4">
        <li>Angular's signals API provides a native solution for unidirectional data flow with fine-grained reactivity.</li>

        <button (click)="code4.hidden = !code4.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

        <span #code4 hidden copyToClipboard>
          <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
            <span>typescript</span>
            <span class="copy-button-wrapper bg-gray-700"></span>
          </div>

          <pre>
            <code
              [highlight]="code_4"
              [languages]="['typescript']">
            </code>
          </pre>
        </span>
      </ul>
    </li>
  </ol>

  <br>
  <br>

  <p>Unidirectional Data Flow Patterns in Angular 19</p>
  <ol class="list-decimal pl-4 text-sm">
    <li>
      <strong>Component Input / Output Pattern</strong>:
      The standard Angular pattern for parent-child communication.

      <button (click)="code5.hidden = !code5.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code5 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_5"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>Signal-Based Components</strong>:
      Angular 19's new model for reactive state management.

      <button (click)="code6.hidden = !code6.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code6 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_6"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>Reactive State Services</strong>:
      Using RxJS Observables for state management across components.

      <button (click)="code7.hidden = !code7.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code7 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_7"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
    <li>
      <strong>Redux-Inspired Architecture</strong>:
      Implementation through libraries like NgRx or using Angular's built-in capabilities.

      <button (click)="code8.hidden = !code8.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>

      <span #code8 hidden copyToClipboard>
        <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
          <span>typescript</span>
          <span class="copy-button-wrapper bg-gray-700"></span>
        </div>

        <pre>
          <code
            [highlight]="code_8"
            [languages]="['typescript']">
          </code>
        </pre>
      </span>
    </li>
  </ol>

  <br>
  <br>

  <p>Benefits of Unidirectional Data Flow</p>
  <table class="w-full border-collapse rounded-lg overflow-hidden shadow-md">
    <thead>
      <tr class="bg-gray-800 text-gray-100">
        <th class="py-3 px-4 text-left">Benefit</th>
        <th class="py-3 px-4 text-left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Predictable State Changes</td>
        <td class="py-3 px-4">Changes follow a clear pattern, making behavior predictable and easier to debug.</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Improved Performance</td>
        <td class="py-3 px-4">Angular can optimize change detection with clear data flow patterns.</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Better Debugging</td>
        <td class="py-3 px-4">Errors and unexpected behaviors are easier to trace to their source.</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Component Isolation</td>
        <td class="py-3 px-4">Components are more isolated and reusable with clear input/output contracts.</td>
      </tr>
    </tbody>
  </table>
</ng-template>

<ng-template #bestRef>
  <ol class="list-decimal px-4 text-sm">
    <li>
      <strong class="text-sky-400">Implement Clear Component Boundaries</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Define Explicit Inputs</strong>:
          Clearly define all component inputs using the @Input() decorator, ensuring that data only flows into components through these channels.
        </li>
        <li>
          <strong>Use Typed Interfaces</strong>:
          Create dedicated interfaces for component inputs and outputs to enforce type safety and make data contracts clear.
        </li>
        <li>
          <strong>Avoid Direct DOM Access</strong>:
          Don't bypass Angular's data flow by directly manipulating the DOM or accessing child component properties directly.
        </li>
        <li>
          <strong>Keep Components Focused</strong>:
          Design components with single responsibilities that transform inputs into views, not as data managers.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Prefer Immutable Data Patterns</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Create New References</strong>:
          When modifying collections or objects, create new instances rather than mutating existing ones.
        </li>
        <li>
          <strong>Use Immutability Helpers</strong>:
          Leverage libraries or native methods that promote immutable data transformations.
        </li>
        <li>
          <strong>Implement OnPush Change Detection</strong>:
          Utilize ChangeDetectionStrategy.OnPush in components to rely on immutable inputs for change detection.
        </li>
        <li>
          <strong>Leverage Pure Pipes</strong>:
          Use pure pipes for data transformations in templates to maintain unidirectional flow.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Utilize Angular 19's Signal API</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Adopt Signal Components</strong>:
          Use signal-based components to leverage Angular 19's fine-grained reactivity system.
        </li>
        <li>
          <strong>Implement Computed Signals</strong>:
          Use computed() to derive state from other signals without breaking unidirectional flow.
        </li>
        <li>
          <strong>Control Signal Updates</strong>:
          Update signals only in dedicated effect functions or handlers, maintaining clear data flow.
        </li>
        <li>
          <strong>Signal-Based Inputs</strong>:
          Use input() from @angular/core with signals to maintain unidirectional flow with optimal performance.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Establish Clean Communication Patterns</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Parent-to-Child: Inputs</strong>:
          Pass data down the component tree using property binding with @Input() decorators.
        </li>
        <li>
          <strong>Child-to-Parent: Outputs</strong>:
          Communicate upward using event emitters with @Output() decorators for specific events.
        </li>
        <li>
          <strong>Sibling/Unrelated Components: Services</strong>:
          Use services with observables or signals for state that needs to be shared across disparate components.
        </li>
        <li>
          <strong>Prefer State Services</strong>:
          Create dedicated state management services that enforce unidirectional data flow rather than having components manage shared state.
        </li>
      </ul>
    </li>
    <li>
      <strong class="text-sky-400">Implement Effective State Management</strong>
      <ul class="list-disc pl-4">
        <li>
          <strong>Single Source of Truth</strong>:
          Maintain a clear hierarchy where each piece of data has only one authoritative owner.
        </li>
        <li>
          <strong>Use Effect Handlers</strong>:
          Isolate side effects from state updates using effect() functions or dedicated handler methods.
        </li>
        <li>
          <strong>Consider Observable State</strong>:
          For complex applications, use RxJS-based state management or integrate with libraries like NgRx.
        </li>
        <li>
          <strong>Document Data Flow</strong>:
          Maintain documentation that visualizes how data flows through your application for easier onboarding and debugging.
        </li>
      </ul>
    </li>
  </ol>
</ng-template>

<ng-template #prosConsRef>
  <strong class="text-sky-400">
    Pros:
  </strong>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      <strong>Predictable State Management</strong>
      <ul class="list-disc pl-4">
        <li>
          Unidirectional data flow creates a predictable pattern for state changes, making applications easier to understand, debug, and maintain.
        </li>
      </ul>
    </li>
    <li>
      <strong>Improved Change Detection</strong>
      <ul class="list-disc pl-4">
        <li>
          Clear data flow allows Angular to optimize change detection, particularly when used with OnPush strategy or signals, resulting in better performance.
        </li>
      </ul>
    </li>
    <li>
      <strong>Simplified Debugging</strong>
      <ul class="list-disc pl-4">
        <li>
          When bugs occur, tracing the source of unexpected behavior is easier because data flows in a single direction with clear ownership.
        </li>
      </ul>
    </li>
    <li>
      <strong>Enhanced Component Reusability</strong>
      <ul class="list-disc pl-4">
        <li>
          Components with clear input/output contracts are more isolated and easier to reuse across different parts of an application.
        </li>
      </ul>
    </li>
    <li>
      <strong>Better Testing</strong>
      <ul class="list-disc pl-4">
        <li>
          Components and services designed around unidirectional flow are easier to test because dependencies and interactions are explicit.
        </li>
      </ul>
    </li>
    <li>
      <strong>Compatibility with Modern Patterns</strong>
      <ul class="list-disc pl-4">
        <li>
          Aligns with industry best practices and integrates well with reactive programming, functional approaches, and state management libraries.
        </li>
      </ul>
    </li>
  </ol>

  <br>

  <strong class="text-sky-400">
    Cons:
  </strong>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      <strong>Initial Learning Curve</strong>
      <ul class="list-disc pl-4">
        <li>
          Developers accustomed to bidirectional data flow or imperative programming may need time to adapt to unidirectional patterns.
        </li>
      </ul>
    </li>
    <li>
      <strong>More Boilerplate Code</strong>
      <ul class="list-disc pl-4">
        <li>
          Maintaining strict unidirectional flow often requires more code for event handling, state propagation, and component communication.
        </li>
      </ul>
    </li>
    <li>
      <strong>Complex Component Hierarchies</strong>
      <ul class="list-disc pl-4">
        <li>
          Deep component trees may suffer from "prop drilling" where data must pass through many intermediate components.
        </li>
      </ul>
    </li>
    <li>
      <strong>Potential State Management Overhead</strong>
      <ul class="list-disc pl-4">
        <li>
          For simple applications, unidirectional patterns might introduce unnecessary complexity and state management overhead.
        </li>
      </ul>
    </li>
    <li>
      <strong>Refactoring Challenges</strong>
      <ul class="list-disc pl-4">
        <li>
          Restructuring component hierarchies can be more involved when strict unidirectional data flow is maintained.
        </li>
      </ul>
    </li>
    <li>
      <strong>Performance Considerations</strong>
      <ul class="list-disc pl-4">
        <li>
          Creating new object references for immutability can impact memory usage and garbage collection in high-throughput scenarios.
        </li>
      </ul>
    </li>
  </ol>

  <br>

  <p>
    Unidirectional data flow in Angular 19 provides significant benefits for application predictability, maintainability, and debugging. While it introduces some initial complexity and potential boilerplate, the long-term advantages for application stability and performance make it a recommended approach for most Angular applications, especially with the new signals API making implementation more efficient.
  </p>

  <br>

  <table class="w-full border-collapse rounded-lg overflow-hidden shadow-md mt-4">
    <thead>
      <tr class="bg-gray-800 text-gray-100">
        <th class="py-3 px-4 text-left w-1/2">Pros</th>
        <th class="py-3 px-4 text-left w-1/2">Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Predictable state management</td>
        <td class="py-3 px-4">Initial learning curve</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Improved change detection</td>
        <td class="py-3 px-4">More boilerplate code</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Simplified debugging</td>
        <td class="py-3 px-4">Complex component hierarchies</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Enhanced component reusability</td>
        <td class="py-3 px-4">Potential state management overhead</td>
      </tr>
      <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Better testing</td>
        <td class="py-3 px-4">Refactoring challenges</td>
      </tr>
      <tr class="bg-gray-950 hover:bg-gray-800 transition-colors">
        <td class="py-3 px-4">Compatibility with modern patterns</td>
        <td class="py-3 px-4">Performance considerations</td>
      </tr>
    </tbody>
  </table>
</ng-template>

<ng-template #topicsRef>
  <p>
    Related topics to Unidirectional Data Flow in Angular 19:
  </p>

  <br>

  <ol class="list-decimal px-10 text-sm">
    <li>
      <strong>Angular Signals</strong>
      <p>
        Angular 19's signals API provides a native implementation of unidirectional data flow with fine-grained reactivity.
      </p>
    </li>
    <li>
      <strong>Component Communication</strong>
      <p>
        Various patterns for passing data and events between components while maintaining unidirectional flow.
      </p>
    </li>
    <li>
      <strong>Change Detection</strong>
      <p>
        Angular's mechanism for detecting and responding to changes, optimized through unidirectional data flow patterns.
      </p>
    </li>
    <li>
      <strong>State Management Libraries</strong>
      <p>
        External solutions like NgRx, NGXS, and Akita that implement unidirectional data flow at scale.
      </p>
    </li>
    <li>
      <strong>RxJS Observables</strong>
      <p>
        Reactive programming library integrated with Angular that enables functional reactive patterns with unidirectional data flow.
      </p>
    </li>
    <li>
      <strong>Immutability Patterns</strong>
      <p>
        Techniques for handling data without mutation, supporting Angular's change detection and unidirectional flow.
      </p>
    </li>
    <li>
      <strong>OnPush Change Detection</strong>
      <p>
        Performance optimization strategy that works well with immutable data and unidirectional flow patterns.
      </p>
    </li>
    <li>
      <strong>Flux/Redux Architecture</strong>
      <p>
        Design pattern featuring unidirectional data flow that influenced modern Angular state management approaches.
      </p>
    </li>
  </ol>
</ng-template>
