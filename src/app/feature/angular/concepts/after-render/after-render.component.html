<section class="p-4 text-sm">
  <p class="heading-1 mb-2">
    afterRender
  </p>

  <div class="text-content">
    <p>
      <span class="text-zinc-50 tw-font-medium">afterRender</span>
      is a lifecycle hook introduced in Angular v17 that runs after every render cycle of a component is completed and committed to the DOM. Unlike afterNextRender which runs only once, afterRender executes multiple times throughout the component's lifecycle, making it useful for consistent DOM synchronization.
    </p>

    <br>

    <div class="flex flex-col">
      <div class="flex border-b border-gray-200">
        <button (click)="selectedTab = 1" [class.text-rose-300]="selectedTab===1" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Overview
        </button>
        <button (click)="selectedTab = 2" [class.text-rose-300]="selectedTab===2" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Usage Examples
        </button>
        <button (click)="selectedTab = 3" [class.text-rose-300]="selectedTab===3" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Best Practices
        </button>
        <button (click)="selectedTab = 4" [class.text-rose-300]="selectedTab===4" class="text-sky-400 hover:text-rose-400 font-semibold py-2 px-4 border-b-2 border-transparent hover:border-gray-500 focus:outline-none">
          Comparison
        </button>
      </div>
      <div class="p-4">
        <ng-container [ngSwitch]="selectedTab">
          <div *ngSwitchCase="2">
            <ng-container *ngTemplateOutlet="usageRef;"></ng-container>
          </div>
          <div *ngSwitchCase="3">
            <ng-container *ngTemplateOutlet="bestPracticesRef;"></ng-container>
          </div>
          <div *ngSwitchCase="4">
            <ng-container *ngTemplateOutlet="comparisonRef;"></ng-container>
          </div>
          <div *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="overviewRef;"></ng-container>
          </div>
        </ng-container>
      </div>
    </div>
  </div>
</section>

<ng-template #overviewRef>
  <p class="mb-4">
    <span class="text-zinc-50 tw-font-medium">afterRender</span> is a lifecycle hook that executes after each render cycle is completed. Unlike <code>ngAfterViewInit</code> or <code>ngAfterViewChecked</code>, this hook guarantees that the component's view has been fully committed to the DOM before executing, making it reliable for DOM interactions.
  </p>

  <h3 class="text-lg font-semibold mb-2 text-sky-400">Key Features:</h3>
  <ul class="list-disc pl-6 mb-4">
    <li>Runs after <i>every</i> render cycle is completed (not just the first one)</li>
    <li>Guarantees the DOM has been fully updated and committed</li>
    <li>Executes in the browser environment only, not during server-side rendering</li>
    <li>Works with both Zone.js-based and Zoneless applications</li>
    <li>Available from Angular v17 onwards</li>
  </ul>

  <h3 class="text-lg font-semibold mb-2 text-sky-400">
    Syntax:
    <button (click)="code1.hidden = !code1.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>
  </h3>
  <span #code1 copyToClipboard>
    <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
      <span>typescript</span>
      <span class="copy-button-wrapper bg-gray-700"></span>
    </div>
    <pre class="mt-4"><code [highlight]="code_1" [languages]="['typescript']"></code></pre>
  </span>

  <h3 class="text-lg font-semibold mb-2 text-sky-400">When to Use:</h3>
  <ul class="list-disc pl-6 mb-4">
    <li>Synchronizing third-party UI components with Angular's state changes</li>
    <li>Performing DOM measurements after each render</li>
    <li>Updating canvas or SVG elements in response to data changes</li>
    <li>Implementing custom scroll position restoration</li>
    <li>Handling focus management for accessibility after UI updates</li>
  </ul>

  <div class="mb-4 p-4 bg-gray-800 rounded border-l-4 border-yellow-500">
    <h4 class="font-medium text-zinc-50 mb-1">‚ö†Ô∏è Performance Warning</h4>
    <p>Since <code>afterRender</code> runs after every render cycle, be mindful of performance implications. Perform expensive operations conditionally when necessary rather than on every render.</p>
  </div>
</ng-template>

<ng-template #usageRef>
  <h3 class="text-lg font-semibold text-sky-400">
    Basic Usage:
    <button (click)="code2.hidden = !code2.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>
  </h3>

  <span #code2 copyToClipboard>
    <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
      <span>typescript</span>
      <span class="copy-button-wrapper bg-gray-700"></span>
    </div>
    <pre class="mt-4"><code [highlight]="code_2" [languages]="['typescript']"></code></pre>
  </span>

  <h3 class="text-lg font-semibold mt-2 text-sky-400">
    Syncing with Third-party Libraries:
    <button (click)="code3.hidden = !code3.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>
  </h3>
  <span #code3 copyToClipboard>
    <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
      <span>typescript</span>
      <span class="copy-button-wrapper bg-gray-700"></span>
    </div>
    <pre class="mt-4"><code [highlight]="code_3" [languages]="['typescript']"></code></pre>
  </span>

  <h3 class="text-lg font-semibold mt-2 text-sky-400">
    Managing Focus for Accessibility:
    <button (click)="code4.hidden = !code4.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>
  </h3>
  <span #code4 copyToClipboard>
    <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
      <span>typescript</span>
      <span class="copy-button-wrapper bg-gray-700"></span>
    </div>
    <pre class="mt-4"><code [highlight]="code_4" [languages]="['typescript']"></code></pre>
  </span>

  <h3 class="text-lg font-semibold mt-2 text-sky-400">
    Performance Optimization:
    <button (click)="code5.hidden = !code5.hidden" class="border border-rose-400 rounded-md px-1 text-sky-400">code</button>
  </h3>
  <span #code5 copyToClipboard>
    <div class="flex flex-row justify-between items-center bg-gray-900 px-4 py-2 relative top-5">
      <span>typescript</span>
      <span class="copy-button-wrapper bg-gray-700"></span>
    </div>
    <pre class="mt-4"><code [highlight]="code_5" [languages]="['typescript']"></code></pre>
  </span>
</ng-template>

<ng-template #bestPracticesRef>
  <h3 class="text-lg font-semibold mb-2 text-sky-400">Best Practices:</h3>
  <ul class="list-disc pl-6 mb-4">
    <li class="mb-3">
      <strong>Be Performance Conscious:</strong> Since <code>afterRender</code> runs after every render cycle, ensure that the operations performed inside are optimized and not computationally expensive, as they could impact frame rates.
    </li>
    <li class="mb-3">
      <strong>Implement Conditional Execution:</strong> Use state flags or comparisons to determine if operations within <code>afterRender</code> are actually needed for a particular render cycle.
    </li>
    <li class="mb-3">
      <strong>Clean Up Resources:</strong> If you set up subscriptions or observers in <code>afterRender</code>, make sure to clean them up in <code>ngOnDestroy</code> to prevent memory leaks.
    </li>
    <li class="mb-3">
      <strong>Avoid Triggering Change Detection:</strong> Be careful not to trigger additional change detection cycles from within <code>afterRender</code> to prevent infinite loops.
    </li>
    <li class="mb-3">
      <strong>Handle SSR Gracefully:</strong> Remember that <code>afterRender</code> only runs in browser environments. Design your components to handle server-side rendering without relying on this hook.
    </li>
    <li class="mb-3">
      <strong>Compare with afterNextRender:</strong> For one-time DOM initialization, prefer <code>afterNextRender</code> over <code>afterRender</code> for better performance.
    </li>
  </ul>

  <div class="mb-4 p-4 bg-gray-800 rounded border-l-4 border-green-500">
    <h4 class="font-medium text-zinc-50 mb-1">üí° Pro Tip</h4>
    <p>For expensive DOM operations, consider debouncing or throttling the function called within <code>afterRender</code> to improve performance, especially for rapidly changing data.</p>
  </div>
</ng-template>

<ng-template #comparisonRef>
  <h3 class="text-lg font-semibold mb-4 text-sky-400">Comparison with Other Lifecycle Hooks</h3>

  <div class="overflow-x-auto">
    <table class="w-full border-collapse rounded-lg overflow-hidden shadow-md mb-6">
      <thead>
        <tr class="bg-gray-800 text-gray-100">
          <th class="py-3 px-4 text-left">Lifecycle Hook</th>
          <th class="py-3 px-4 text-left">When It Runs</th>
          <th class="py-3 px-4 text-left">Guaranteed DOM?</th>
          <th class="py-3 px-4 text-left">Frequency</th>
          <th class="py-3 px-4 text-left">Best For</th>
        </tr>
      </thead>
      <tbody>
        <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
          <td class="py-3 px-4"><code>afterRender</code></td>
          <td class="py-3 px-4">After each render cycle is committed</td>
          <td class="py-3 px-4 text-green-500">Yes</td>
          <td class="py-3 px-4">Multiple times</td>
          <td class="py-3 px-4">Continuous DOM sync with state</td>
        </tr>
        <tr class="border-b border-gray-700 bg-gray-950 hover:bg-gray-800 transition-colors">
          <td class="py-3 px-4"><code>afterNextRender</code></td>
          <td class="py-3 px-4">After first render is committed</td>
          <td class="py-3 px-4 text-green-500">Yes</td>
          <td class="py-3 px-4">Once only</td>
          <td class="py-3 px-4">Initial DOM setup</td>
        </tr>
        <tr class="border-b border-gray-700 bg-gray-900 hover:bg-gray-800 transition-colors">
          <td class="py-3 px-4"><code>ngAfterViewInit</code></td>
          <td class="py-3 px-4">After component's view is initialized</td>
          <td class="py-3 px-4 text-red-500">No</td>
          <td class="py-3 px-4">Once only</td>
          <td class="py-3 px-4">Initial component setup</td>
        </tr>
        <tr class="bg-gray-950 hover:bg-gray-800 transition-colors">
          <td class="py-3 px-4"><code>ngAfterViewChecked</code></td>
          <td class="py-3 px-4">After change detection checks component's view</td>
          <td class="py-3 px-4 text-red-500">No</td>
          <td class="py-3 px-4">Multiple times</td>
          <td class="py-3 px-4">Responding to view changes</td>
        </tr>
      </tbody>
    </table>
  </div>

  <h3 class="text-lg font-semibold mb-2 text-sky-400">Key Differences from afterNextRender:</h3>
  <ul class="list-disc pl-6 mb-4">
    <li><code>afterRender</code> runs after every render, while <code>afterNextRender</code> runs only once after the first render.</li>
    <li>Use <code>afterRender</code> when you need to continuously sync with DOM changes throughout the component's lifecycle.</li>
    <li>Using <code>afterRender</code> without proper optimization can impact performance more than <code>afterNextRender</code>.</li>
  </ul>

  <h3 class="text-lg font-semibold mb-2 text-sky-400">Key Differences from ngAfterViewChecked:</h3>
  <ul class="list-disc pl-6 mb-4">
    <li><code>afterRender</code> guarantees the DOM has been committed, while <code>ngAfterViewChecked</code> runs after change detection but before the browser has painted.</li>
    <li><code>afterRender</code> is safer for DOM measurements and manipulations as it ensures the browser has rendered the changes.</li>
    <li><code>ngAfterViewChecked</code> may run more frequently in some cases, as it's tied to Angular's change detection.</li>
  </ul>
</ng-template>
